<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · GEBT.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">GEBT.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li class="is-active"><a class="tocitem" href>Library</a><ul class="internal"><li><a class="tocitem" href="#Public-API"><span>Public API</span></a></li><li><a class="tocitem" href="#Private-API"><span>Private API</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/byuflowlab/GEBT.jl/blob/master/docs/src/library.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Library"><a class="docs-heading-anchor" href="#Library">Library</a><a id="Library-1"></a><a class="docs-heading-anchor-permalink" href="#Library" title="Permalink"></a></h1><ul><li><a href="#Library">Library</a></li><ul><li><a href="#Public-API">Public API</a></li><ul><li><a href="#Creating-an-Assembly">Creating an Assembly</a></li><li><a href="#Defining-Prescribed-Conditions">Defining Prescribed Conditions</a></li><li><a href="#Pre-Initializing-Memory-for-an-Analysis">Pre-Initializing Memory for an Analysis</a></li><li><a href="#Performing-an-Analysis">Performing an Analysis</a></li><li><a href="#Post-Processing">Post-Processing</a></li></ul><li><a href="#Private-API">Private API</a></li><ul><li><a href="#Math">Math</a></li><li><a href="#Points">Points</a></li><li><a href="#Elements">Elements</a></li><li><a href="#Loads">Loads</a></li><li><a href="#System">System</a></li></ul><li><a href="#Index">Index</a></li></ul></ul><h2 id="Public-API"><a class="docs-heading-anchor" href="#Public-API">Public API</a><a id="Public-API-1"></a><a class="docs-heading-anchor-permalink" href="#Public-API" title="Permalink"></a></h2><h3 id="Creating-an-Assembly"><a class="docs-heading-anchor" href="#Creating-an-Assembly">Creating an Assembly</a><a id="Creating-an-Assembly-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-an-Assembly" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GEBT.curve_length" href="#GEBT.curve_length"><code>GEBT.curve_length</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">curve_length(r1, r2, k)</code></pre><p>Calculate the length of a curve given its endpoints and its curvature vector</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/assembly.jl#L129-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.discretize_beam" href="#GEBT.discretize_beam"><code>GEBT.discretize_beam</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">discretize_beam(L, r, d; Cab = Matrix(I,3,3)), k = zeros(3))</code></pre><p>Discretize a beam according to the discretization provided in <code>d</code>, an array that ranges from 0 to 1, with 0 representing the beginning of the beam and 1 representing the end of the beam.</p><p>If <code>d</code> is an integer, the beam is discretized into <code>d</code> uniformly spaced elements.</p><p>Return the lengths, endpoints, midpoints, and rotation matrices of the beam elements.</p><p><strong>Arguments</strong></p><ul><li><code>L</code>: Beam length</li><li><code>r</code>: Beam starting point</li><li><code>d</code>: Discretization vector</li><li><code>Cab</code>: 3x3 beam rotation matrix at the starting point</li><li><code>k</code>: curvature vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/assembly.jl#L78-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.Assembly-Tuple{Any,Any,Any}" href="#GEBT.Assembly-Tuple{Any,Any,Any}"><code>GEBT.Assembly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Assembly(points, start, stop; kwargs...)</code></pre><p>Construct an assembly of connected nonlinear beam elements for analysis.  Beam lengths and midpoints may be manually specified in case beam elements are curved rather than straight.</p><p><strong>Arguments</strong></p><ul><li><code>points</code>: Array of all beam element endpoints</li><li><code>start</code>: Array containing point index where each beam element starts</li><li><code>stop</code>: Array containing point index where each beam element stops</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>stiffness</code>: Array of (6 x 6) stiffness matrices for each beam element, alternative to providing <code>compliance</code></li><li><code>compliance</code>: Array of (6 x 6) compliance matrices for each beam element, defaults to <code>zeros(6,6)</code> for each beam element</li><li><code>mass</code>: Array of (6 x 6) mass matrices for each beam element, alternative to providing <code>minv</code></li><li><code>minv</code>: Array of (6 x 6) mass matrices for each beam element, defaults to the identity matrix for each beam element</li><li><code>frames</code>: Array of (3 x 3) direction cosine matrices for each beam element, defaults to the identity matrix for each beam element</li><li><code>lengths</code>: Array containing the length of each beam, defaults to the distance between beam endpoints</li><li><code>midpoints</code>: Array containing the midpoint of each beam element, defaults to the average of the beam element endpoints</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/assembly.jl#L21-L41">source</a></section></article><h3 id="Defining-Prescribed-Conditions"><a class="docs-heading-anchor" href="#Defining-Prescribed-Conditions">Defining Prescribed Conditions</a><a id="Defining-Prescribed-Conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-Prescribed-Conditions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GEBT.PrescribedConditions-Tuple{}" href="#GEBT.PrescribedConditions-Tuple{}"><code>GEBT.PrescribedConditions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">PrescribedConditions(dt=0.0; kwargs...)</code></pre><p>Construct an object of type PrescribedConditions which stores the prescribed conditions for a point at each time step.</p><p>Prescribed conditions may be assigned as either a scalar parameter or as a function of time.</p><p><strong>Arguments</strong></p><ul><li><code>dt</code>: Time step size.</li><li><code>nstep</code>: The total length of the time vector</li><li><code>ux</code>: Prescribed x-direction displacement of the point</li><li><code>uy</code>: Prescribed y-direction displacement of the point</li><li><code>uz</code>: Prescribed z-direction displacement of the point</li><li><code>theta_x</code>: Prescribed first Wiener-Milenkovic parameter of the point</li><li><code>theta_y</code>: Prescribed second Wiener-Milenkovic parameter of the point</li><li><code>theta_z</code>: Prescribed third Wiener-Milenkovic parameter of the point</li><li><code>Fx</code>: Prescribed force in x-direction applied on the point</li><li><code>Fy</code>: Prescribed force in y-direction applied on the point</li><li><code>Fz</code>: Prescribed force in z-direction applied on the point</li><li><code>Mx</code>: Prescribed moment about x-axis applied on the point</li><li><code>My</code>: Prescribed moment about y-axis applied on the point</li><li><code>Mz</code>: Prescribed moment about z-axis applied on the point</li><li><code>Fx_follower</code>: Prescribed follower force in x-direction applied on the point</li><li><code>Fy_follower</code>: Prescribed follower force in y-direction applied on the point</li><li><code>Fz_follower</code>: Prescribed follower force in z-direction applied on the point</li><li><code>Mx_follower</code>: Prescribed follower moment about x-axis applied on the point</li><li><code>My_follower</code>: Prescribed follower moment about y-axis applied on the point</li><li><code>Mz_follower</code>: Prescribed follower moment about z-axis applied on the point</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/loads.jl#L14-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.DistributedLoads-Tuple{Any,Any}" href="#GEBT.DistributedLoads-Tuple{Any,Any}"><code>GEBT.DistributedLoads</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">DistributedLoads(assembly, ibeam[, dt]; kwargs...)</code></pre><p>Integrates the specified distributed loads over the element for each time step.</p><p><strong>Arguments</strong></p><ul><li><code>ΔL</code>: The length of the beam element</li><li><code>dt</code>: Time step size.  If omitted a single time step is assumed and specified</li></ul><p>functions become a function of <code>s</code> only.</p><ul><li><code>s1 = 0.0</code>: Start of beam element</li><li><code>s2 = 1.0</code>: End of beam element</li><li><code>nstep</code>: The total length of the time vector</li><li><code>method = (f, a, b) -&gt; trapz(range(a, b, length=100), f.(range(a, b, length=100)))</code>:  Method to use for integrating over the elements.  Defaults to the trapezoidal</li></ul><pre><code class="language-none">method with 100 points.</code></pre><ul><li><code>fx = (s, t) -&gt; 0.0</code>: Distributed non-follower force on beam element in x-direction</li><li><code>fy = (s, t) -&gt; 0.0</code>: Distributed non-follower force on beam element in y-direction</li><li><code>fz = (s, t) -&gt; 0.0</code>: Distributed non-follower force on beam element in z-direction</li><li><code>mx = (s, t) -&gt; 0.0</code>: Distributed non-follower moment on beam element in x-direction</li><li><code>my = (s, t) -&gt; 0.0</code>: Distributed non-follower moment on beam element in y-direction</li><li><code>mz = (s, t) -&gt; 0.0</code>: Distributed non-follower moment on beam element in z-direction</li><li><code>fx_follower = (s, t) -&gt; 0.0</code>: Distributed follower force on beam element in x-direction</li><li><code>fy_follower = (s, t) -&gt; 0.0</code>: Distributed follower force on beam element in y-direction</li><li><code>fz_follower = (s, t) -&gt; 0.0</code>: Distributed follower force on beam element in z-direction</li><li><code>mx_follower = (s, t) -&gt; 0.0</code>: Distributed follower moment on beam element in x-direction</li><li><code>my_follower = (s, t) -&gt; 0.0</code>: Distributed follower moment on beam element in y-direction</li><li><code>mz_follower = (s, t) -&gt; 0.0</code>: Distributed follower moment on beam element in z-direction</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/loads.jl#L193-L220">source</a></section></article><h3 id="Pre-Initializing-Memory-for-an-Analysis"><a class="docs-heading-anchor" href="#Pre-Initializing-Memory-for-an-Analysis">Pre-Initializing Memory for an Analysis</a><a id="Pre-Initializing-Memory-for-an-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Pre-Initializing-Memory-for-an-Analysis" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GEBT.System-Tuple{Any,Any,Any}" href="#GEBT.System-Tuple{Any,Any,Any}"><code>GEBT.System</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">System([TF=eltype(assembly),] assembly, points, static)</code></pre><p>Initialize an object of type <code>System</code> which stores the system state, residual vector, current time function values,and jacobian matrices as well as pointers to be able to access their contents.</p><p><strong>Arguments:</strong></p><ul><li><code>TF:</code> (optional) Used to specify floating point type used by resulting <code>System</code> object</li><li><code>assembly</code>: Assembly of rigidly connected nonlinear beam elements</li><li><code>points</code>: Point indices which should be preserved in the system of equations</li><li><code>static</code>: Flag indicating whether system matrices will be used only for static simulations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/system.jl#L46-L58">source</a></section></article><h3 id="Performing-an-Analysis"><a class="docs-heading-anchor" href="#Performing-an-Analysis">Performing an Analysis</a><a id="Performing-an-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Performing-an-Analysis" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GEBT.static_analysis" href="#GEBT.static_analysis"><code>GEBT.static_analysis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">static_analysis(assembly; kwargs...)</code></pre><p>Perform a static analysis of the system of nonlinear beams contained in <code>assembly</code>. Return the resulting system and a flag indicating whether the iteration procedure converged.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>prescribed_conditions=Dict{Int,PrescribedConditions{Float64}}()</code>: Dictionary</li></ul><p>holding PrescribedConditions composite types for the points in <code>keys(prescribed_conditions)</code></p><ul><li><code>distributed_loads=Dict{Int,DistributedLoads{Float64}}()</code>: Dictionary holding</li></ul><p>DistributedLoads composite types for the beam elements in <code>keys(distributed_loads)</code></p><ul><li><code>linear=false</code>: Set to <code>true</code> for a linear analysis</li><li><code>method=:newton</code>: Method (as defined in NLsolve) to solve nonlinear system of equations</li><li><code>linesearch=LineSearches.BackTracking()</code>: Line search used to solve nonlinear system of equations</li><li><code>ftol=1e-12</code>: tolerance for solving nonlinear system of equations</li><li><code>iterations=1000</code>: maximum iterations for solving the nonlinear system of equations</li><li><code>nstep=1</code>: Number of time steps. May be used in conjunction with time varying</li></ul><p>prescribed conditions and distributed loads to gradually increase 	displacements/loads.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/analyses.jl#L1-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.static_analysis!" href="#GEBT.static_analysis!"><code>GEBT.static_analysis!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">static_analysis!(system, assembly; kwargs...)</code></pre><p>Pre-allocated version of <code>static_analysis</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/analyses.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.steady_state_analysis" href="#GEBT.steady_state_analysis"><code>GEBT.steady_state_analysis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">steady_state_analysis(assembly; kwargs...)</code></pre><p>Perform a steady-state analysis for the system of nonlinear beams contained in <code>assembly</code>.  Return the resulting system and a flag indicating whether the iteration procedure converged.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>prescribed_conditions=Dict{Int,PrescribedConditions{Float64}}()</code>: Dictionary</li></ul><p>holding PrescribedConditions composite types for the points in <code>keys(prescribed_conditions)</code></p><ul><li><code>distributed_loads=Dict{Int,DistributedLoads{Float64}}()</code>: Dictionary holding</li></ul><p>DistributedLoads composite types for the beam elements in <code>keys(distributed_loads)</code></p><ul><li><code>linear=false</code>: Set to <code>true</code> for a linear analysis</li><li><code>method=:newton</code>: Method (as defined in NLsolve) to solve nonlinear system of equations</li><li><code>linesearch=LineSearches.BackTracking()</code>: Line search used to solve nonlinear system of equations</li><li><code>ftol=1e-12</code>: tolerance for solving nonlinear system of equations</li><li><code>iterations=1000</code>: maximum iterations for solving the nonlinear system of equations</li><li><code>nstep=1</code>: Number of time steps. May be used in conjunction with time varying</li></ul><p>prescribed conditions, distributed loads, and global motion to gradually 	increase displacements/loads.</p><ul><li><code>origin = zeros(3)</code>: Global frame origin</li><li><code>linear_velocity = fill(zeros(3), nstep)</code>: Global frame linear velocity for each time step.</li><li><code>angular_velocity = fill(zeros(3), nstep)</code>: Global frame angular velocity for each time step</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/analyses.jl#L122-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.steady_state_analysis!" href="#GEBT.steady_state_analysis!"><code>GEBT.steady_state_analysis!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">steady_state_analysis!(system, assembly; kwargs...)</code></pre><p>Pre-allocated version of <code>steady_state_analysis</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/analyses.jl#L179-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.eigenvalue_analysis" href="#GEBT.eigenvalue_analysis"><code>GEBT.eigenvalue_analysis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eigenvalue_analysis(assembly; kwargs...)</code></pre><p>Compute the eigenvalues and eigenvectors of the system of nonlinear beams contained in <code>assembly</code> by calling ARPACK.  Return the modified system, eigenvalues, eigenvectors, and a convergence flag indicating whether the corresponding steady-state analysis converged.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>prescribed_conditions=Dict{Int,PrescribedConditions{Float64}}()</code>: Dictionary</li></ul><p>holding PrescribedConditions composite types for the points in <code>keys(prescribed_conditions)</code></p><ul><li><code>distributed_loads=Dict{Int,DistributedLoads{Float64}}()</code>: Dictionary holding</li></ul><p>DistributedLoads composite types for the beam elements in <code>keys(distributed_loads)</code></p><ul><li><code>linear=false</code>: Set to <code>true</code> for a linear analysis</li><li><code>method = :newton</code>: Method (as defined in NLsolve) to solve nonlinear system of equations</li><li><code>linesearch = LineSearches.BackTracking()</code>: Line search used to solve nonlinear system of equations</li><li><code>ftol = 1e-12</code>: tolerance for solving nonlinear system of equations</li><li><code>iterations = 1000</code>: maximum iterations for solving the nonlinear system of equations</li><li><code>nstep=1</code>: Number of time steps. May be used in conjunction with time varying</li></ul><p>prescribed conditions, distributed loads, and global motion to gradually 	increase displacements/loads.</p><ul><li><code>origin = zeros(3)</code>: Global frame origin</li><li><code>linear_velocity = fill(zeros(3), nstep)</code>: Global frame linear velocity for each time step.</li><li><code>angular_velocity = fill(zeros(3), nstep)</code>: Global frame angular velocity for each time step</li><li><code>nev = 6</code>: Number of eigenvalues to compute</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/analyses.jl#L269-L294">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.eigenvalue_analysis!" href="#GEBT.eigenvalue_analysis!"><code>GEBT.eigenvalue_analysis!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eigenvalue_analysis!(system, assembly; kwargs...)</code></pre><p>Pre-allocated version of <code>eigenvalue_analysis</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/analyses.jl#L330-L334">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.time_domain_analysis" href="#GEBT.time_domain_analysis"><code>GEBT.time_domain_analysis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">time_domain_analysis(assembly, dt; kwargs...)</code></pre><p>Perform a time-domain analysis for the system of nonlinear beams contained in <code>assembly</code>.  Return the final system, a post-processed solution history, and a convergence flag indicating whether the iterations converged for each time step.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>prescribed_conditions = Dict{Int,PrescribedConditions{Float64}}()</code>: Dictionary</li></ul><p>holding PrescribedConditions composite types for the points in <code>keys(prescribed_conditions)</code></p><ul><li><code>distributed_loads = Dict{Int,DistributedLoads{Float64}}()</code>: Dictionary holding</li></ul><p>DistributedLoads composite types for the beam elements in <code>keys(distributed_loads)</code></p><ul><li><code>linear=false</code>: Set to <code>true</code> for a linear analysis</li><li><code>method=:newton</code>: Method (as defined in NLsolve) to solve nonlinear system of equations</li><li><code>linesearch=LineSearches.BackTracking()</code>: Line search used to solve nonlinear system of equations</li><li><code>ftol=1e-12</code>: tolerance for solving nonlinear system of equations</li><li><code>iterations=1000</code>: maximum iterations for solving the nonlinear system of equations</li><li><code>nstep=1</code>: The total length of the time vector</li><li><code>origin = zeros(3)</code>: Global frame origin</li><li><code>linear_velocity = fill(zeros(3), nstep)</code>: Global frame linear velocity for each time step.</li><li><code>angular_velocity = fill(zeros(3), nstep)</code>: Global frame angular velocity for each time step.</li><li><code>u0=fill(zeros(3), length(assembly.elements))</code>: initial displacment of each beam element,</li><li><code>theta0=fill(zeros(3), length(assembly.elements))</code>: initial angular displacement of each beam element,</li><li><code>udot0=fill(zeros(3), length(assembly.elements))</code>: initial time derivative with respect to <code>u</code></li><li><code>thetadot0=fill(zeros(3), length(assembly.elements))</code>: initial time derivative with respect to <code>theta</code></li><li><code>save=1:nstep</code>: Steps at which to save the time history</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/analyses.jl#L425-L451">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.time_domain_analysis!" href="#GEBT.time_domain_analysis!"><code>GEBT.time_domain_analysis!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">time_domain_analysis!(system, assembly, dt; kwargs...)</code></pre><p>Pre-allocated version of <code>time_domain_analysis</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/analyses.jl#L495-L499">source</a></section></article><h3 id="Post-Processing"><a class="docs-heading-anchor" href="#Post-Processing">Post-Processing</a><a id="Post-Processing-1"></a><a class="docs-heading-anchor-permalink" href="#Post-Processing" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GEBT.AssemblyState-Tuple{Any,Any}" href="#GEBT.AssemblyState-Tuple{Any,Any}"><code>GEBT.AssemblyState</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">AssemblyState(system, assembly, x = system.x;
	prescribed_conditions = Dict{Int,PrescribedConditions{Float64}}())</code></pre><p>Post-process the system state given the solution vector <code>x</code>.  Return an object of type <code>AssemblyState</code> that defines the state of the assembly for the time step.</p><p>If <code>prescribed_conditions</code> is not provided, all point state variables are assumed to be displacements/rotations, rather than their actual identities as used in the analysis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/postprocess.jl#L56-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.AssemblyState" href="#GEBT.AssemblyState"><code>GEBT.AssemblyState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AssemblyState{TF, TP&lt;:AbstractVector{PointState{TF}}, TE&lt;:AbstractVector{ElementState{TF}}}</code></pre><p>Struct for storing state variables for the points and elements in an assembly.</p><p><strong>Fields:</strong></p><ul><li><code>points::TP</code>: Array of <code>PointState</code>s for each point in the assembly</li><li><code>elements::TE</code>: Array of <code>ElementState</code>s for each element in the assembly</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/postprocess.jl#L41-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.left_eigenvectors" href="#GEBT.left_eigenvectors"><code>GEBT.left_eigenvectors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">left_eigenvectors(system, λ, V)
left_eigenvectors(K, M, λ, V)</code></pre><p>Compute the left eigenvector matrix <code>Us</code> for the <code>system</code> using inverse power iteration given the eigenvalues <code>λ</code> and the corresponding right eigenvector matrix <code>V</code>.</p><p>The complex conjugate of each left eigenvector is stored in each row of the matrix <code>Us</code></p><p>Left and right eigenvectors satisfy the following M-orthogonality condition:</p><ul><li>u&#39;<em>M</em>v = 1 if u and v correspond to the same eigenvalue</li><li>u&#39;<em>M</em>v = 0 if u and v correspond to different eigenvalues</li></ul><p>This function assumes that <code>system</code> has not been modified since the eigenvalues and right eigenvectors were computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/postprocess.jl#L233-L250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.wiener_milenkovic" href="#GEBT.wiener_milenkovic"><code>GEBT.wiener_milenkovic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">wiener_milenkovic(c)</code></pre><p>Construct a Wiener-Milenkovic rotation matrix, given the three Wiener-Milenkovic rotation parameters in <code>c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/math.jl#L14-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.write_vtk" href="#GEBT.write_vtk"><code>GEBT.write_vtk</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">write_vtk(name, assembly::Assembly, [state::AssemblyState, scaling=1.0])</code></pre><p>Write the deformed geometry (and associated data) to a VTK file for visualization using ParaView.  The deflections can be scaled with <code>scaling</code>.</p><p>The <code>state</code> and <code>scaling</code> parameters may be omitted to write the original geometry to a VTK file without any associated data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/postprocess.jl#L152-L160">source</a></section></article><h2 id="Private-API"><a class="docs-heading-anchor" href="#Private-API">Private API</a><a id="Private-API-1"></a><a class="docs-heading-anchor-permalink" href="#Private-API" title="Permalink"></a></h2><h3 id="Math"><a class="docs-heading-anchor" href="#Math">Math</a><a id="Math-1"></a><a class="docs-heading-anchor-permalink" href="#Math" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GEBT.tilde" href="#GEBT.tilde"><code>GEBT.tilde</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tilde(x)</code></pre><p>Construct the cross product operator matrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/math.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.get_C" href="#GEBT.get_C"><code>GEBT.get_C</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_C(c)</code></pre><p>Alias for <code>wiener_milenkovic(c)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/math.jl#L32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.get_C_t" href="#GEBT.get_C_t"><code>GEBT.get_C_t</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_C_t([C, ] c, c_t)</code></pre><p>Calculate the derivative of a Wiener-Milenkovic rotation matrix <code>C</code> with respect to the scalar parameter <code>t</code>. <code>c_t</code> is the derivative of <code>c</code> with respect to <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/math.jl#L39-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.get_C_c" href="#GEBT.get_C_c"><code>GEBT.get_C_c</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_C_c([C, ] c)</code></pre><p>Calculate the derivative of the Wiener-Milenkovic rotation matrix <code>C</code> with respect to each of the rotation parameters in <code>c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/math.jl#L69-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.get_C_cdot" href="#GEBT.get_C_cdot"><code>GEBT.get_C_cdot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_C_cdot([C, ] c)</code></pre><p>Calculate the derivative of the time derivative of the Wiener-Milenkovic rotation matrix <code>C</code> with respect to each of the time derivatives of <code>c</code>. Used for constructing the &quot;mass&quot; matrix for eigenvalue computations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/math.jl#L109-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.get_Q" href="#GEBT.get_Q"><code>GEBT.get_Q</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_Q(c)</code></pre><p>Calculate the matrix Q as defined in the paper &quot;Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters&quot; by Qi Wang and Wenbin Yu.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/math.jl#L148-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.get_Q_c" href="#GEBT.get_Q_c"><code>GEBT.get_Q_c</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_Q_c(c)
get_Q_c(Q, c)</code></pre><p>Calculate the derivative of the matrix <code>Q</code> with respect to each of the rotation parameters in <code>c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/math.jl#L159-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.get_Qinv" href="#GEBT.get_Qinv"><code>GEBT.get_Qinv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_Qinv(c)</code></pre><p>Calculate the matrix inverse <code>Qinv</code> as defined in the paper &quot;Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters&quot; by Qi Wang and Wenbin Yu.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/math.jl#L185-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.get_Qinv_c" href="#GEBT.get_Qinv_c"><code>GEBT.get_Qinv_c</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_Qinv_c(c)</code></pre><p>Calculate the derivative of the matrix inverse <code>Qinv</code> with respect to each of the rotation parameters in <code>c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/math.jl#L194-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.mul3" href="#GEBT.mul3"><code>GEBT.mul3</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mul3(A_1, A_2, A_3, b)</code></pre><p>Returns the product of a 3x3x3 tensor represented by <code>A_1</code>, <code>A_2</code>, and <code>A_3</code> with the vector <code>b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/math.jl#L209-L214">source</a></section></article><h3 id="Points"><a class="docs-heading-anchor" href="#Points">Points</a><a id="Points-1"></a><a class="docs-heading-anchor-permalink" href="#Points" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GEBT.point_variables" href="#GEBT.point_variables"><code>GEBT.point_variables</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">point_variables(x, icol)
point_variables(x, icol, prescribed_conditions, istep)</code></pre><p>Extract u, θ, F, M for the point described by the point state variables at <code>icol</code> in x after incorporating the prescribed conditions in <code>prescribed_conditions</code></p><p>Note that the degrees of freedom that are not specified in <code>prescribed_conditions</code> are used as state variables (e.g. prescribing F[2] would mean u[2] = x[icol+1])</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/point.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.insert_point_residual!" href="#GEBT.insert_point_residual!"><code>GEBT.insert_point_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">insert_point_residual!(resid, irow_b, irow_p, u, θ, F, M, side)</code></pre><p>Modify the equilibrium and constitutive equations to account for the point variables given by u, θ, F, M</p><p>If irow<em>b != irow</em>p, assume that the equilibrium equations have already been modified</p><p><strong>Arguments</strong></p><ul><li>resid: Residual vector</li><li>irow_b: Row index of the first equilibrium/compatability equation for one side of the beam element</li><li>irow_p: Row index of the first equilibrium equation for the point</li><li>u: Displacement of the point</li><li>θ: Rotation of the point</li><li>F: External forces imposed on the point</li><li>M: External moments imposed on the point</li><li>side: Side of beam (-1 (left) or 1 (right))</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/point.jl#L71-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.point_residual!" href="#GEBT.point_residual!"><code>GEBT.point_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">point_residual!(resid, x, ipoint, assembly, prescribed_conditions, icol,
	irow_p, irow_beam1, irow_beam2)</code></pre><p>Adds a points contributions to the residual vector</p><p><strong>Arguments</strong></p><ul><li><code>resid</code>: residual vector</li><li><code>x</code>: current state vector</li><li><code>ipoint</code>: index of point</li><li><code>assembly</code>: assembly of interconnected beam elements</li><li><code>prescribed_conditions</code>: dictionary of prescribed conditions</li><li><code>icol</code>: starting index for the point&#39;s state variables</li><li><code>irow_p</code>: Row index of the first equilibrium equation for the point</li><li><code>irow_beam1</code>: Row index of first equation for the left side of each beam</li><li><code>irow_beam2</code>: Row index of first equation for the right side of each beam</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/point.jl#L110-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.point_follower_jacobians" href="#GEBT.point_follower_jacobians"><code>GEBT.point_follower_jacobians</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">point_follower_jacobians(x, icol, prescribed_conditions)</code></pre><p>Calculate the jacobians of the follower forces/moments with respect to θ</p><p><strong>Arguments</strong></p><ul><li>x: Current state variable vector</li><li>icol: Row/Column index of the first state variable for the point</li><li>prescribed_conditions: Prescribed conditions for the point</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/point.jl#L161-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.insert_point_jacobian!" href="#GEBT.insert_point_jacobian!"><code>GEBT.insert_point_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">insert_point_jacobian!(jacob, irow_b, irow_p, icol, prescribed_conditions, side, F_θ, M_θ)</code></pre><p>Modify the jacobian entries for the equilibrium and constitutive equations to account for the point variables at icol</p><p>If irow<em>b != irow</em>p, assume that the equilibrium equations have already been modified</p><p><strong>Arguments</strong></p><ul><li>jacob: Jacobian of residual vector with respect to state vectors</li><li>irow_b: Row index of the first equilibrium/compatability equation for one side of the beam element</li><li>irow_p: Row index of the first equilibrium equation for the point</li><li>icol: Row/Column index of the first state variable for the point</li><li>prescribed_conditions: Prescribed force/displacement and moment/rotation on point</li><li>side: Side of beam (-1 (left) or 1 (right))</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/point.jl#L228-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.point_jacobian!" href="#GEBT.point_jacobian!"><code>GEBT.point_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">point_jacobian!(jacob, x, ipoint, assembly, prescribed_conditions, icol,
	irow_p, irow_beam1, irow_beam2)</code></pre><p>Adds a points contributions to the residual vector</p><p><strong>Arguments</strong></p><ul><li><code>jacob</code>: residual vector</li><li><code>x</code>: current state vector</li><li><code>ipoint</code>: index of point</li><li><code>assembly</code>: assembly of interconnected beam elements</li><li><code>prescribed_conditions</code>: dictionary of prescribed conditions</li><li><code>istep</code>: current time step</li><li><code>icol</code>: starting index for the point&#39;s state variables</li><li><code>irow_p</code>: Row index of the first equilibrium equation for the point</li><li><code>irow_beam1</code>: Row index of first equation for the left side of each beam</li><li><code>irow_beam2</code>: Row index of first equation for the right side of each beam</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/point.jl#L306-L323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.PointState" href="#GEBT.PointState"><code>GEBT.PointState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PointState</code></pre><p>Holds the state variables for a point</p><p><strong>Fields:</strong></p><ul><li><code>u</code>: Displacement variables for the point</li><li><code>theta</code>: Wiener-Milenkovic rotation variables for the point</li><li><code>F</code>: Externally applied forces on the point</li><li><code>M</code>: Externally applied moments on the point</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/postprocess.jl#L1-L11">source</a></section></article><h3 id="Elements"><a class="docs-heading-anchor" href="#Elements">Elements</a><a id="Elements-1"></a><a class="docs-heading-anchor-permalink" href="#Elements" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GEBT.Element" href="#GEBT.Element"><code>GEBT.Element</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Element{TF}</code></pre><p>Composite type that defines a beam element&#39;s properties</p><p><strong>Fields</strong></p><ul><li><code>L</code>: Length of the beam element</li><li><code>x</code>: Location of the beam element (the midpoint of the beam element)</li><li><code>C11</code>: Upper left portion of the beam element&#39;s compliance matrix</li><li><code>C12</code>: Upper right portion of the beam element&#39;s compliance matrix</li><li><code>C22</code>: Lower right portion of the beam element&#39;s compliance matrix</li><li><code>minv11</code>: Upper left portion of the inverse of the beam element&#39;s mass matrix</li><li><code>minv12</code>: Upper right portion of the inverse of the beam element&#39;s mass matrix</li><li><code>minv22</code>: Lower right portion of the inverse of the beam element&#39;s mass matrix</li><li><code>Cab</code>: Rotation matrix from the global frame to beam element&#39;s frame</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/element.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.element_strain" href="#GEBT.element_strain"><code>GEBT.element_strain</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">element_strain(element, F, M)</code></pre><p>Calculate the strain of a beam element given the resultant force and moments</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/element.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.element_curvature" href="#GEBT.element_curvature"><code>GEBT.element_curvature</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">element_curvature(element, F, M)</code></pre><p>Calculate the curvature of a beam element given the resultant force and moments</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/element.jl#L61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.element_linear_velocity" href="#GEBT.element_linear_velocity"><code>GEBT.element_linear_velocity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">element_linear_velocity(element, P, H)</code></pre><p>Calculate the linear velocity of a beam element given the linear and angular momenta</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/element.jl#L68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.element_angular_velocity" href="#GEBT.element_angular_velocity"><code>GEBT.element_angular_velocity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">element_angular_velocity(element, P, H)</code></pre><p>Calculate the angular velocity of a beam element given the linear and angular momenta</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/element.jl#L75-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.element_properties" href="#GEBT.element_properties"><code>GEBT.element_properties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">element_properties(x, icol, beam)
element_properties(x, icol, beam, x0, v0, ω0)
element_properties(x, icol, ibeam, beam, x0, v0, ω0, u, θ, udot, θdot)
element_properties(x, icol, ibeam, beam, x0, v0, ω0, udot, θdot_init, CtCabPdot, CtCabHdot, dt)</code></pre><p>Extract/calculate the properties of a specific beam element.</p><p>There are four implementations corresponding to the following analysis types:</p><ul><li>Static</li><li>Dynamic - Steady State</li><li>Dynamic - Initial Step (for initializing time domain simulations)</li><li>Dynamic - Time Marching</li></ul><p>See &quot;GEBT: A general-purpose nonlinear analysis tool for composite beams&quot; by Wenbin Yu and &quot;Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters&quot; by Qi Wang and Wenbin Yu.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: current state vector</li><li><code>icol</code>: starting index for the beam&#39;s state variables</li><li><code>ibeam</code>: beam element index</li><li><code>beam</code>: beam element</li></ul><p><strong>Additional Arguments for Dynamic Analyses</strong></p><ul><li><code>x0</code>: Global frame origin (for the current time step)</li><li><code>v0</code>: Global frame linear velocity (for the current time step)</li><li><code>ω0</code>: Global frame angular velocity (for the current time step)</li></ul><p><strong>Additional Arguments for Initial Step Analyses</strong></p><ul><li><code>u</code>: deflection variables for each beam element</li><li><code>θ</code>: rotation variables for each beam element</li><li><code>udot</code>: time derivative of u for each beam element</li><li><code>θdot</code>: time derivative of θ for each beam element</li></ul><p><strong>Additional Arguments for Time Marching Analyses</strong></p><ul><li><code>udot_init</code>: <code>2/dt*u + udot</code> for each beam element from the previous time step</li><li><code>θdot_init</code>: <code>2/dt*θ + θdot</code> for each beam element from the previous time step</li><li><code>CtCabPdot_init</code>: <code>2/dt*C&#39;*Cab*P + C&#39;*Cab*Pdot</code> for each beam element from the previous time step</li><li><code>CtCabHdot_init</code>: <code>2/dt*C&#39;*Cab*H + C&#39;*Cab*Hdot</code> for each beam element from the previous time step</li><li><code>dt</code>: time step size</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/element.jl#L82-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.dynamic_element_properties" href="#GEBT.dynamic_element_properties"><code>GEBT.dynamic_element_properties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dynamic_element_properties(x, icol, beam, x0, v0, ω0)</code></pre><p>Extract/Compute <code>v</code>, <code>ω</code>, <code>P</code>, <code>H</code>, <code>V</code>, and <code>Ω</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/element.jl#L197-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.element_equations" href="#GEBT.element_equations"><code>GEBT.element_equations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">element_equations(ΔL, Cab, CtCab, u, θ, F, M, γ, κ)
element_equations(ΔL, Cab, CtCab, u, θ, F, M, γ, κ, v, ω, P, H, V, Ω)
element_equations(ΔL, Cab, CtCab, u, θ, F, M, γ, κ, v, ω, P, H, V, Ω,
	udot, θdot, CtCabPdot, CtCabHdot)</code></pre><p>Evaluate the nonlinear equations for a beam element.</p><p>There are three implementations corresponding to the following analysis types:</p><ul><li>Static</li><li>Dynamic - Steady State</li><li>Dynamic - Initial Step or Time Marching</li></ul><p>See &quot;GEBT: A general-purpose nonlinear analysis tool for composite beams&quot; by Wenbin Yu and &quot;Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters&quot; by Qi Wang and Wenbin Yu.</p><p><strong>Arguments:</strong></p><ul><li><code>ΔL</code>: Length of the beam element</li><li><code>Ct</code>: Rotation tensor of the beam deformation in the &quot;a&quot; frame, transposed</li><li><code>Cab</code>: Direction cosine matrix from &quot;a&quot; to &quot;b&quot; frame for the element</li><li><code>CtCab</code>: <code>C&#39;*Cab</code>, precomputed for efficiency</li><li><code>u</code>: Displacement variables for the element [u1, u2, u3]</li><li><code>θ</code>: Rotation variables for the element [θ1, θ2, θ3]</li><li><code>F</code>: Force variables for the element [F1, F2, F3]</li><li><code>M</code>: Moment variables for the element [M1, M2, M3]</li><li><code>γ</code>: Engineering strains in the element [γ11, 2γ12, 2γ13]</li><li><code>κ</code>: Curvatures in the element [κ1, κ2, κ3]</li></ul><p><strong>Additional Arguments for Dynamic Analyses</strong></p><ul><li><code>v</code>: Linear velocity of element in global frame &quot;a&quot; [v1, v2, v3]</li><li><code>ω</code>: Angular velocity of element in global frame &quot;a&quot; [ω1, ω2, ω3]</li><li><code>P</code>: Linear momenta for the element [P1, P2, P3]</li><li><code>H</code>: Angular momenta for the element [H1, H2, H3]</li><li><code>V</code>: Velocity of the element</li><li><code>Ω</code>: Rotational velocity of the element</li></ul><p><strong>Additional Arguments for Initial Step Analysis</strong></p><ul><li><code>udot</code>: user-specified time derivative of u</li><li><code>θdot</code>: user-specified time derivative of θ</li><li><code>CtCabPdot</code>: C&#39;<em>Cab</em>Pdot state variable</li><li><code>CtCabHdot</code>: C&#39;<em>Cab</em>Hdot state variable</li></ul><p><strong>Additional Arguments for Time Marching Analysis</strong></p><ul><li><code>udot</code>: <code>2/dt*(u-u_p) - udot_p</code> for this beam element where <code>_p</code> denotes values</li></ul><p>taken from the previous time step</p><ul><li><code>θdot</code>: <code>2/dt*(θ-θ_p) - θdot_p</code> for this beam element where <code>_p</code> denotes values</li></ul><p>taken from the previous time step</p><ul><li><code>CtCabPdot</code>: <code>2/dt*(C&#39;*Cab*P - (C&#39;*Cab*P)_p) - (C&#39;*Cab*Pdot)_p</code> for this beam</li></ul><p>element where <code>_p</code> denotes values taken from the previous time step</p><ul><li><code>CtCabHdot</code>: <code>2/dt*(C&#39;*Cab*H - (C&#39;*Cab*H)_p) - (C&#39;*Cab*Hdot)_p</code> for this beam</li></ul><p>element where <code>_p</code> denotes values taken from the previous time step</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/element.jl#L216-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.insert_element_residual!" href="#GEBT.insert_element_residual!"><code>GEBT.insert_element_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">insert_element_residual!(resid, irow_b, irow_b1, irow_p1, irow_b2, irow_p2, f_u1, f_u2, f_ψ1,
	f_ψ2, f_F1, f_F2, f_M1, f_M2)
insert_element_residual!(resid, irow_b, irow_b1, irow_p1, irow_b2, irow_p2, f_u1, f_u2, f_ψ1,
	f_ψ2, f_F1, f_F2, f_M1, f_M2, f_P, f_H)</code></pre><p>Insert beam element resultants into the residual equation.  Initialize equilibrium and constitutive equations if they are not yet initialized.</p><p>If <code>irow_b1 != irow_p1</code> and/or <code>irow_b2 != irow_p2</code>, assume the equilibrium equations for the left and/or right side are already initialized</p><p>There are two implementations corresponding to the following analysis types:</p><ul><li>Static</li><li>Dynamic - Steady State, Initial Step, or Time Marching</li></ul><p><strong>Arguments</strong></p><ul><li><code>resid</code>: System residual vector</li><li><code>irow_b1</code>: Row index of the first equation for the left side of the beam element  (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p1</code>: Row index of the first equation for the point on the left side of the beam element</li><li><code>irow_b1</code>: Row index of the first equation for the right side of the beam element</li></ul><p>(a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</p><ul><li><code>irow_p2</code>: Row index of the first equation for the point on the right side of the beam element</li><li><code>f_u1</code>, <code>f_u2</code>: Resultant displacements for the left and right side of the beam element, respectively</li><li><code>f_ψ1</code>, <code>f_ψ2</code>: Resultant rotations for the left and right side of the beam element, respectively</li><li><code>f_F1</code>, <code>f_F2</code>: Resultant forces for the left and right side of the beam element, respectively</li><li><code>f_M1</code>, <code>f_M2</code>: Resultant moments for the left and right side of the beam element, respectively</li></ul><p><strong>Additional Arguments for Dynamic Analyses</strong></p><ul><li><code>f_P</code>: Resultant linear momenta of the beam element</li><li><code>f_H</code>: Resultant angular momenta of the beam element</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/element.jl#L339-L371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.element_residual!" href="#GEBT.element_residual!"><code>GEBT.element_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">element_residual!(resid, x, ibeam, beam, distributed_loads, icol, irow_b,
	irow_b1, irow_p1, irow_b2, irow_p2)
element_residual!(resid, x, ibeam, beam, distributed_loads, icol, irow_b,
	irow_b1, irow_p1, irow_b2, irow_p2, x0, v0, ω0)
element_residual!(resid, x, ibeam, beam, distributed_loads, icol, irow_b,
	irow_b1, irow_p1, irow_b2, irow_p2, x0, v0, ω0, u0, θ0, udot0, θdot0)
element_residual!(resid, x, ibeam, beam, distributed_loads, icol, irow_b,
	irow_b1, irow_p1, irow_b2, irow_p2, x0, v0, ω0, udot_init, θdot_init,
	CtCabPdot_init, CtCabHdot_init, dt)</code></pre><p>Compute and add a beam element&#39;s contributions to the residual vector</p><p>There are four implementations corresponding to the following analysis types:</p><ul><li>Static</li><li>Dynamic - Steady State</li><li>Dynamic - Initial Step (for initializing time domain simulations)</li><li>Dynamic - Time Marching</li></ul><p>See &quot;GEBT: A general-purpose nonlinear analysis tool for composite beams&quot; by Wenbin Yu and &quot;Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters&quot; by Qi Wang and Wenbin Yu.</p><p><strong>Arguments</strong></p><ul><li><code>resid</code>: System residual vector</li><li><code>x</code>: current state vector</li><li><code>ibeam</code>: beam element index</li><li><code>beam</code>: beam element</li><li><code>distributed_loads</code>: dictionary with all distributed loads</li><li><code>istep</code>: current time step</li><li><code>icol</code>: starting index for the beam&#39;s state variables</li><li><code>irow_b1</code>: Row index of the first equation for the left side of the beam element  (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p1</code>: Row index of the first equation for the point on the left side of the beam element</li><li><code>irow_b2</code>: Row index of the first equation for the right side of the beam element  (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p2</code>: Row index of the first equation for the point on the right side of the beam element</li></ul><p><strong>Additional Arguments for Dynamic Analyses</strong></p><ul><li><code>x0</code>: Global frame origin (for the current time step)</li><li><code>v0</code>: Global frame linear velocity (for the current time step)</li><li><code>ω0</code>: Global frame angular velocity (for the current time step)</li></ul><p><strong>Additional Arguments for Initial Step Analyses</strong></p><ul><li><code>u0</code>: initial deflection variables for each beam element</li><li><code>θ0</code>: initial rotation variables for each beam element</li><li><code>udot0</code>: initial time derivative of u for each beam element</li><li><code>θdot0</code>: initial time derivative of θ for each beam element</li></ul><p><strong>Additional Arguments for Time Marching Analyses</strong></p><ul><li><code>udot_init</code>: <code>2/dt*u + udot</code> for each beam element from the previous time step</li><li><code>θdot_init</code>: <code>2/dt*θ + θdot</code> for each beam element from the previous time step</li><li><code>CtCabPdot_init</code>: <code>2/dt*C&#39;*Cab*P + C&#39;*Cab*Pdot</code> for each beam element from the previous time step</li><li><code>CtCabHdot_init</code>: <code>2/dt*C&#39;*Cab*H + C&#39;*Cab*Hdot</code> for each beam element from the previous time step</li><li><code>dt</code>: time step size</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/element.jl#L457-L512">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.element_jacobian_equations" href="#GEBT.element_jacobian_equations"><code>GEBT.element_jacobian_equations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">element_jacobian_equations(beam, ΔL, Ct, Cab, CtCab, θ, F, M, γ, κ, Ct_θ1,
	Ct_θ2, Ct_θ3)
element_jacobian_equations(beam, ΔL, Cab, CtCab, θ, F, M, γ, κ, ω, P, H, V,
	Ct_θ1, Ct_θ2, Ct_θ3)
element_jacobian_equations(beam, ΔL, Cab, CtCab, θ, F, γ, ω, P, V, θdot)
element_jacobian_equations(beam, ΔL, Cab, CtCab, θ, F, M, γ, κ, ω, P, H, V,
	θdot, dt, Ct_θ1, Ct_θ2, Ct_θ3)</code></pre><p>Find the jacobians of the nonlinear equations for a beam element with respect to the state variables given the distributed loads on the beam element and the beam element&#39;s properties.</p><p>There are four implementations corresponding to the following analysis types:</p><ul><li>Static</li><li>Dynamic - Steady State</li><li>Dynamic - Initial Step (for initializing time domain simulations)</li><li>Dynamic - Time Marching</li></ul><p>See &quot;GEBT: A general-purpose nonlinear analysis tool for composite beams&quot; by Wenbin Yu and &quot;Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters&quot; by Qi Wang and Wenbin Yu.</p><p><strong>Arguments:</strong></p><ul><li><code>beam</code>: Beam element</li><li><code>ΔL</code>: Length of the beam element</li><li><code>Ct</code>: Rotation tensor of the beam deformation in the &quot;a&quot; frame, transposed</li><li><code>Cab</code>: Direction cosine matrix from &quot;a&quot; to &quot;b&quot; frame for the element</li><li><code>CtCab</code>: <code>C&#39;*Cab</code>, precomputed for efficiency</li><li><code>u</code>: Displacement variables for the element [u1, u2, u3]</li><li><code>θ</code>: Rotation variables for the element [θ1, θ2, θ3]</li><li><code>F</code>: Force variables for the element [F1, F2, F3]</li><li><code>M</code>: Moment variables for the element [M1, M2, M3]</li><li><code>γ</code>: Engineering strains in the element [γ11, 2γ12, 2γ13]</li><li><code>κ</code>: Curvatures in the element [κ1, κ2, κ3]</li><li><code>Ct_θ1</code>: Gradient of <code>Ct</code> w.r.t. <code>θ[1]</code></li><li><code>Ct_θ2</code>: Gradient of <code>Ct</code> w.r.t. <code>θ[2]</code></li><li><code>Ct_θ3</code>: Gradient of <code>Ct</code> w.r.t. <code>θ[3]</code></li><li><code>f1_θ</code>: Gradient w.r.t. θ of integrated distributed force for left side of element</li><li><code>m1_θ</code>: Gradient w.r.t. θ of integrated distributed moment for left side of element</li><li><code>f2_θ</code>: Gradient w.r.t. θ of integrated distributed force for right side of element</li><li><code>m2_θ</code>: Gradient w.r.t. θ of integrated distributed moment for right side of element</li></ul><p><strong>Additional Arguments for Dynamic Analyses</strong></p><ul><li><code>v</code>: Linear velocity of element in global frame &quot;a&quot; [v1, v2, v3]</li><li><code>ω</code>: Angular velocity of element in global frame &quot;a&quot; [ω1, ω2, ω3]</li><li><code>P</code>: Linear momenta for the element [P1, P2, P3]</li><li><code>H</code>: Angular momenta for the element [H1, H2, H3]</li><li><code>V</code>: Velocity of the element</li><li><code>Ω</code>: Rotational velocity of the element</li></ul><p><strong>Additional Arguments for Initial Step Analyses</strong></p><ul><li><code>udot</code>: user-specified time derivative of u for this beam element</li><li><code>θdot</code>: user-specified time derivative of θ for this beam element</li><li><code>CtCabPdot</code>: <code>C&#39;*Cab*Pdot</code> (which is a state variable for the initial step analysis)</li><li><code>CtCabHdot</code>: <code>C&#39;*Cab*Hdot</code> (which is a state variable for the initial step analysis)</li></ul><p><strong>Additional Arguments for Time Marching Analyses</strong></p><ul><li><code>udot</code>: <code>-2/dt*u - udot</code> for each beam element from the previous time step</li><li><code>θdot_init</code>: <code>-2/dt*θ - θdot</code> for each beam element from the previous time step</li><li><code>CtCabPdot</code>: <code>-2/dt*C&#39;*Cab*P - C&#39;*Cab*Pdot</code> for each beam element from the previous time step</li><li><code>CtCabHdot</code>: <code>-2/dt*C&#39;*Cab*H - C&#39;*Cab*Hdot</code> for each beam element from the previous time step</li><li><code>dt</code>: time step size</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/element.jl#L626-L689">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.insert_element_jacobian!" href="#GEBT.insert_element_jacobian!"><code>GEBT.insert_element_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">insert_element_jacobian!(jacob, irow_b1, irow_p1, irow_b2, irow_p2, icol,
	f_u1_θ, f_u2_θ, f_u1_F, f_u2_F,
	f_ψ1_θ, f_ψ2_θ, f_ψ1_F, f_ψ2_F, f_ψ1_M, f_ψ2_M,
	f_F1_u, f_F2_u, f_F1_θ, f_F2_θ, f_F1_F, f_F2_F, f_F1_M, f_F2_M,
	f_M1_θ, f_M2_θ, f_M1_F, f_M2_F, f_M1_M, f_M2_M)
insert_element_jacobian!(jacob, irow_b1, irow_p1, irow_b2, irow_p2, icol,
	f_u1_θ, f_u2_θ, f_u1_F, f_u2_F, f_u1_P, f_u2_P,
	f_ψ1_θ, f_ψ2_θ, f_ψ1_F, f_ψ2_F, f_ψ1_M, f_ψ2_M, f_ψ1_P, f_ψ2_P, f_ψ1_H, f_ψ2_H,
	f_F1_u, f_F2_u, f_F1_θ, f_F2_θ, f_F1_F, f_F2_F, f_F1_M, f_F2_M,
	f_M1_θ, f_M2_θ, f_M1_F, f_M2_F, f_M1_M, f_M2_M,
	f_P_u, f_P_θ, f_P_P, f_P_H,
	f_H_θ, f_H_P, f_H_H)
insert_element_jacobian!(jacob, irow_b1, irow_p1, irow_b2, irow_p2, icol,
	f_u1_CtCabPdot, f_u2_CtCabPdot, f_u1_F, f_u2_F, f_u1_P, f_u2_P,
	f_ψ1_CtCabHdot, f_ψ2_CtCabHdot, f_ψ1_F, f_ψ2_F, f_ψ1_M, f_ψ2_M, f_ψ1_P, f_ψ2_P, f_ψ1_H, f_ψ2_H,
	f_F1_F, f_F2_F, f_F1_M, f_F2_M,
	f_M1_F, f_M2_F, f_M1_M, f_M2_M,
	f_P_P, f_P_H,
	f_H_P, f_H_H)</code></pre><p>Insert the the beam element jacobian entries into the jacobian matrix</p><p>There are three implementations corresponding to the following analysis types:</p><ul><li>Static</li><li>Dynamic - Steady State or Time Marching</li><li>Dynamic - Initial Step (for initializing time domain simulations)</li></ul><p><strong>Arguments</strong></p><ul><li><code>jacob</code>: System jacobian matrix</li><li><code>icol_p1</code>: Row/column index of the first unknown for the left endpoint (a value &lt;= 0 indicates the unknowns have been eliminated from the system of equations)</li><li><code>irow_b1</code>: Row index of the first equation for the left side of the beam</li><li><code>irow_p1</code>: Row index of the first equation for the point on the left side of the beam</li><li><code>icol_p2</code>: Row/column index of the first unknown for the right endpoint</li></ul><p>(a value &lt;= 0 indicates the unknowns have been eliminated from the system of equations)</p><ul><li><code>irow_b2</code>: Row index of the first equation for the right side of the beam</li><li><code>irow_p2</code>: Row index of the first equation for the point on the right side of the beam</li><li><code>icol</code>: Row/Column index corresponding to the first beam state variable</li></ul><p>All other arguments use the following naming convention:</p><ul><li><code>f_y_x</code>: Jacobian of element equation &quot;y&quot; with respect to state variable &quot;x&quot;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/element.jl#L995-L1038">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.element_jacobian!" href="#GEBT.element_jacobian!"><code>GEBT.element_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">element_jacobian!(jacob, x, ibeam, beam, distributed_loads, icol, irow_b,
	irow_b1, irow_p1, irow_b2, irow_p2)
element_jacobian!(jacob, x, ibeam, beam, distributed_loads, icol, irow_b,
	irow_b1, irow_p1, irow_b2, irow_p2, x0, v0, ω0)
element_jacobian!(jacob, x, ibeam, beam, distributed_loads, icol, irow_b,
	irow_b1, irow_p1, irow_b2, irow_p2, x0, v0, ω0, u0, θ0, udot0, θdot0)
element_jacobian!(jacob, x, ibeam, beam, distributed_loads, icol, irow_b,
	irow_b1, irow_p1, irow_b2, irow_p2, x0, v0, ω0, udot_init, θdot_init,
	CtCabPdot_init, CtCabHdot_init, dt)</code></pre><p>Adds a beam element&#39;s contributions to the jacobian matrix</p><p>There are four implementations corresponding to the following analysis types:</p><ul><li>Static</li><li>Dynamic - Steady State</li><li>Dynamic - Initial Step (for initializing time domain simulations)</li><li>Dynamic - Time Marching</li></ul><p>See &quot;GEBT: A general-purpose nonlinear analysis tool for composite beams&quot; by Wenbin Yu and &quot;Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters&quot; by Qi Wang and Wenbin Yu.</p><p><strong>Arguments</strong></p><ul><li><code>jacob</code>: System jacobian matrix</li><li><code>x</code>: current state vector</li><li><code>ibeam</code>: beam element index</li><li><code>beam</code>: beam element</li><li><code>distributed_loads</code>: dictionary with all distributed loads</li><li><code>istep</code>: current time step</li><li><code>icol</code>: starting index for the beam&#39;s state variables</li><li><code>irow_b1</code>: Row index of the first equation for the left side of the beam element  (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p1</code>: Row index of the first equation for the point on the left side of the beam element</li><li><code>irow_b2</code>: Row index of the first equation for the right side of the beam element  (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p2</code>: Row index of the first equation for the point on the right side of the beam element</li></ul><p><strong>Additional Arguments for Dynamic Analyses</strong></p><ul><li><code>x0</code>: Global frame origin (for the current time step)</li><li><code>v0</code>: Global frame linear velocity (for the current time step)</li><li><code>ω0</code>: Global frame angular velocity (for the current time step)</li></ul><p><strong>Additional Arguments for Initial Step Analyses</strong></p><ul><li><code>u0</code>: initial deflection variables for each beam element</li><li><code>θ0</code>: initial rotation variables for each beam element</li><li><code>udot0</code>: initial time derivative of u for each beam element</li><li><code>θdot0</code>: initial time derivative of θ for each beam element</li></ul><p><strong>Additional Arguments for Time Marching Analyses</strong></p><ul><li><code>udot_init</code>: <code>2/dt*u + udot</code> for each beam element from the previous time step</li><li><code>θdot_init</code>: <code>2/dt*θ + θdot</code> for each beam element from the previous time step</li><li><code>CtCabPdot_init</code>: <code>2/dt*C&#39;*Cab*P + C&#39;*Cab*Pdot</code> for each beam element from the previous time step</li><li><code>CtCabHdot_init</code>: <code>2/dt*C&#39;*Cab*H + C&#39;*Cab*Hdot</code> for each beam element from the previous time step</li><li><code>dt</code>: time step size</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/element.jl#L1200-L1255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.element_mass_matrix_properties" href="#GEBT.element_mass_matrix_properties"><code>GEBT.element_mass_matrix_properties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">element_mass_matrix_properties(x, icol, beam)</code></pre><p>Extract/Compute the properties needed for mass matrix construction: <code>ΔL</code>, <code>Ct</code>, <code>Cab</code>, <code>CtCab</code>, <code>θ</code>, <code>P</code>, <code>H</code>, <code>Ctdot_cdot1</code>, <code>Ctdot_cdot2</code>, and Ctdot_cdot3</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/element.jl#L1407-L1412">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.element_mass_matrix_equations" href="#GEBT.element_mass_matrix_equations"><code>GEBT.element_mass_matrix_equations</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">element_mass_matrix_equations(ΔL, Ct, Cab, CtCab, θ, P, H)</code></pre><p>Calculates the jacobians of the nonlinear equations for a beam element with respect to the time derivatives of the state variables.</p><p>See &quot;GEBT: A general-purpose nonlinear analysis tool for composite beams&quot; by Wenbin Yu and &quot;Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters&quot; by Qi Wang and Wenbin Yu.</p><p><strong>Arguments:</strong></p><ul><li><code>ΔL</code>: Length of the beam element</li><li><code>Ct</code>: Rotation tensor of the beam deformation in the &quot;a&quot; frame, transposed</li><li><code>Cab</code>: Direction cosine matrix from &quot;a&quot; to &quot;b&quot; frame for the element</li><li><code>θ</code>: Rotation variables for the element [θ1, θ2, θ3]</li><li><code>P</code>: Linear momenta for the element [P1, P2, P3]</li><li><code>H</code>: Angular momenta for the element [H1, H2, H3]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/element.jl#L1429-L1446">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.insert_element_mass_matrix!" href="#GEBT.insert_element_mass_matrix!"><code>GEBT.insert_element_mass_matrix!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">insert_element_mass_matrix!(jacob, irow_b1, irow_p1, irow_b2, irow_p2, icol,
	f_u1_θdot, f_u2_θdot, f_u1_Pdot, f_u2_Pdot, f_ψ1_θdot, f_ψ2_θdot,
	f_ψ1_Hdot, f_ψ2_Hdot, f_P_udot, f_H_θdot)</code></pre><p>Insert the beam element&#39;s contributions into the &quot;mass matrix&quot;: the jacobian of the residual equations with respect to the time derivatives of the state variables</p><p><strong>Arguments</strong></p><ul><li><code>jacob</code>: System jacobian matrix (mass matrix)</li><li><code>irow_b1</code>: Row index of the first equation for the left side of the beam</li><li><code>irow_p1</code>: Row index of the first equation for the point on the left side of the beam</li><li><code>irow_b2</code>: Row index of the first equation for the right side of the beam</li><li><code>irow_p2</code>: Row index of the first equation for the point on the right side of the beam</li><li><code>icol</code>: Row/Column index corresponding to the first beam state variable</li></ul><p>All other arguments use the following naming convention:</p><ul><li><code>f_y_x</code>: Jacobian of element equation &quot;y&quot; with respect to state variable &quot;x&quot;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/element.jl#L1476-L1494">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.element_mass_matrix!" href="#GEBT.element_mass_matrix!"><code>GEBT.element_mass_matrix!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">element_mass_matrix!(jacob, x, beam, icol, irow_b, irow_b1, irow_p1, irow_b2, irow_p2)</code></pre><p>Add the beam element&#39;s contributions to the &quot;mass matrix&quot;: the jacobian of the residual equations with respect to the time derivatives of the state variables</p><p>See &quot;GEBT: A general-purpose nonlinear analysis tool for composite beams&quot; by Wenbin Yu and &quot;Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters&quot; by Qi Wang and Wenbin Yu.</p><p><strong>Arguments</strong></p><ul><li><code>jacob</code>: System jacobian matrix</li><li><code>x</code>: current state vector</li><li><code>beam</code>: beam element</li><li><code>icol</code>: starting index for the beam&#39;s state variables</li><li><code>irow_b1</code>: Row index of the first equation for the left side of the beam element  (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p1</code>: Row index of the first equation for the point on the left side of the beam element</li><li><code>irow_b2</code>: Row index of the first equation for the right side of the beam element  (a value &lt;= 0 indicates the equations have been eliminated from the system of equations)</li><li><code>irow_p2</code>: Row index of the first equation for the point on the right side of the beam element</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/element.jl#L1518-L1539">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.ElementState" href="#GEBT.ElementState"><code>GEBT.ElementState</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ElementState</code></pre><p>Holds the state variables for an element</p><p><strong>Fields:</strong></p><ul><li><code>u</code>: Displacement variables for the element</li><li>theta: Wiener-Milenkovic rotation variables for the element</li><li><code>F</code>: Resultant forces for the element</li><li><code>M</code>: Resultant moments for the element</li><li><code>P</code>: Linear momenta of the element</li><li><code>H</code>: Angular momenta of the element</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/postprocess.jl#L19-L31">source</a></section></article><h3 id="Loads"><a class="docs-heading-anchor" href="#Loads">Loads</a><a id="Loads-1"></a><a class="docs-heading-anchor-permalink" href="#Loads" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GEBT.PrescribedConditions" href="#GEBT.PrescribedConditions"><code>GEBT.PrescribedConditions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PrescribedConditions{T}</code></pre><p>Describes the forces, moments, displacements, and/or rotations prescribed at a point for each time step</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/loads.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.DistributedLoads" href="#GEBT.DistributedLoads"><code>GEBT.DistributedLoads</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DistributedLoads{T}</code></pre><p>Contains the integrated distributed forces and moments for each beam element for each time step.</p><p><strong>Fields</strong></p><ul><li>f1: Integrated non-follower distributed force for the beam element&#39;s left endpoint for each time step</li><li>f2: Integrated non-follower distributed force for the beam element&#39;s right endpoint for each time step</li><li>m1: Integrated non-follower distributed moment for the beam element&#39;s left endpoint for each time step</li><li>m2: Integrated non-follower distributed moment for the beam element&#39;s right endpoint for each time step</li><li>f1_follower: Integrated follower distributed force for the beam element&#39;s left endpoint for each time step</li><li>f2_follower: Integrated follower distributed force for the beam element&#39;s right endpoint for each time step</li><li>m1_follower: Integrated follower distributed moment for the beam element&#39;s left endpoint for each time step</li><li>m2_follower: Integrated follower distributed moment for the beam element&#39;s right endpoint for each time step</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/loads.jl#L166-L180">source</a></section></article><h3 id="System"><a class="docs-heading-anchor" href="#System">System</a><a id="System-1"></a><a class="docs-heading-anchor-permalink" href="#System" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="GEBT.Assembly" href="#GEBT.Assembly"><code>GEBT.Assembly</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Assembly{TF, TP&lt;:AbstractVector{&lt;:AbstractVector{TF}}, TC&lt;:AbstractVector{&lt;:Integer}, TE&lt;:AbstractVector{Element{TF}}}</code></pre><p>Composite type that defines an assembly of connected nonlinear beam elements for analysis.</p><p><strong>Fields</strong></p><ul><li><code>points</code>: Array of all beam element endpoints</li><li><code>start</code>: Array containing point index where each beam element starts</li><li><code>stop</code>: Array containing point index where each beam element stops</li><li><code>element</code>: Array of <code>Element</code>s</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/assembly.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.System" href="#GEBT.System"><code>GEBT.System</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">System{TF, TV&lt;:AbstractVector{TF}, TM&lt;:AbstractMatrix{TF}, TTF&lt;:AbstractVector{TF}}</code></pre><p>Contains the system state, residual vector, and jacobian matrices as well as pointers to be able to access their contents.  Also contains additional storage needed for time domain simulations.</p><p><strong>Fields:</strong></p><ul><li><code>static</code>: Flag indicating whether system matrices are only valid for static analyses</li><li><code>x</code>: State vector</li><li><code>r</code>: Residual vector</li><li><code>K</code>: System jacobian matrix with respect to the state variables</li><li><code>M</code>: System jacobian matrix with respect to the time derivative of the state variables</li><li><code>irow_pt</code>: Row index of first equilibrium equation for each point</li><li><code>irow_beam</code>: Row index of first equation for just this beam element</li><li><code>irow_beam1</code>: Row index of first equation for the left side of each beam</li><li><code>irow_beam2</code>: Row index of first equation for the right side of each beam</li><li><code>icol_pt</code>: Row/Column index of first state variable for each point</li><li><code>icol_beam</code>: Row/Column index of first state variable for each beam element</li><li><code>current_step</code>: Current time step</li><li><code>udot_init</code>: <code>2/dt*u + udot</code> for each beam element from the previous time step</li><li><code>θdot_init</code>: <code>2/dt*θ + θdot</code> for each beam element from the previous time step</li><li><code>CtCabPdot_init</code>: <code>2/dt*C&#39;*Cab*P + C&#39;*Cab*Pdot</code> for each beam element from the previous time step</li><li><code>CtCabHdot_init</code>: <code>2/dt*C&#39;*Cab*H + C&#39;*Cab*Hdot</code> for each beam element from the previous time step</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/system.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.point_connections" href="#GEBT.point_connections"><code>GEBT.point_connections</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">point_connections(assembly)</code></pre><p>Count the number of beams connected to each point</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/system.jl#L93-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.system_indices" href="#GEBT.system_indices"><code>GEBT.system_indices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">system_indices(assembly, points, n_connections, static)</code></pre><p>Solve for the row indices of the first equilibrium or compatability equations for each point and side of each beam element.  Also solve for the row/column index of each point and beam state variable.</p><p>If only two beams meet at a point, the 6 unknowns associated with that point as well as the 6 compatability equations are eliminated from the system, except if specified in the array <code>points</code>.  Points for which unknowns have been eliminated are assigned a column index of -1.  Beams for which the compatability equations have been eliminated are also assigned an index of -1</p><p><strong>Arguments:</strong></p><ul><li><code>assembly</code>: Assembly of rigidly connected nonlinear beam elements</li><li><code>points</code>: Point indices which should be preserved in the system matrices</li><li><code>n_connections</code>: Number of connections to each point</li><li><code>static</code>: flag indicating whether analysis is static</li></ul><p><strong>Return Arguments:</strong></p><ul><li><code>n</code>: total number of equations/unknowns in the system</li><li><code>irow_pt</code>: Row index of first equilibrium equation for each point</li><li><code>irow_beam</code>: Row index of first equation for just this beam element</li><li><code>irow_beam1</code>: Row index of first equation for the left side of each beam</li><li><code>irow_beam2</code>: Row index of first equation for the right side of each beam</li><li><code>icol_pt</code>: Column index of first state variable for each point</li><li><code>icol_beam</code>: Column index of first state variable for each beam element</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/system.jl#L111-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.system_residual!" href="#GEBT.system_residual!"><code>GEBT.system_residual!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">system_residual!(resid, x, assembly, prescribed_conditions, distributed_loads,
	istep, irow_pt, irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam)
system_residual!(resid, x, assembly, prescribed_conditions, distributed_loads,
	istep, irow_pt, irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam, x0, v0, ω0)
system_residual!(resid, x, assembly, prescribed_conditions, distributed_loads,
	istep, irow_pt, irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam, x0, v0, ω0,
	u, θ, udot, θdot)
system_residual!(resid, x, assembly, prescribed_conditions, distributed_loads,
	istep, irow_pt, irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam, x0, v0, ω0,
	udot, θdot_init, CtCabPdot, CtCabHdot, dt)</code></pre><p>Populate the residual vector <code>resid</code> with the results of the residual equations for the system.</p><p>There are four implementations corresponding to the following analysis types:</p><ul><li>Static</li><li>Dynamic - Steady State</li><li>Dynamic - Initial Step (for initializing time domain simulations)</li><li>Dynamic - Time Marching</li></ul><p>See &quot;GEBT: A general-purpose nonlinear analysis tool for composite beams&quot; by  Wenbin Yu and &quot;Geometrically nonlinear analysis of composite beams using  Wiener-Milenković parameters&quot; by Qi Wang and Wenbin Yu.</p><p><strong>Arguments</strong></p><ul><li><code>resid</code>: System residual vector</li><li><code>x</code>: Current state variables of the system</li><li><code>assembly</code>: Assembly of rigidly connected nonlinear beam elements</li><li><code>prescribed_conditions</code>: Dictionary of prescribed conditions at all time steps</li><li><code>distributed_loads</code>: Dictionary of distributed loads at all time steps</li><li><code>istep</code>: Current time step</li><li><code>irow_pt</code>: Row index of first equilibrium equation for each point</li><li><code>irow_beam</code>: Row index of first equation for just this beam element</li><li><code>irow_beam1</code>: Row index of first equation for the left side of each beam</li><li><code>irow_beam2</code>: Row index of first equation for the right side of each beam</li><li><code>icol_pt</code>: Column index of first state variable for each point</li><li><code>icol_beam</code>: Column index of first state variable for each beam element</li></ul><p><strong>Additional Arguments for Dynamic Analyses</strong></p><ul><li><code>x0</code>: Global frame origin (for the current time step)</li><li><code>v0</code>: Global frame linear velocity (for the current time step)</li><li><code>ω0</code>: Global frame angular velocity (for the current time step)</li></ul><p><strong>Additional Arguments for Initial Step Analyses</strong></p><ul><li><code>u</code>: deflection variables for each beam element</li><li><code>θ</code>: rotation variables for each beam element</li><li><code>udot</code>: time derivative of u for each beam element</li><li><code>θdot</code>: time derivative of θ for each beam element</li></ul><p><strong>Additional Arguments for Time Marching Analyses</strong></p><ul><li><code>udot</code>: <code>-2/dt*u - udot</code> for each beam element from the previous time step</li><li><code>θdot_init</code>: <code>-2/dt*θ - θdot</code> for each beam element from the previous time step</li><li><code>CtCabPdot</code>: <code>-2/dt*C&#39;*Cab*P - C&#39;*Cab*Pdot</code> for each beam element from the previous time step</li><li><code>CtCabHdot</code>: <code>-2/dt*C&#39;*Cab*H - C&#39;*Cab*Hdot</code> for each beam element from the previous time step</li><li><code>dt</code>: time step size</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/system.jl#L235-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.system_jacobian!" href="#GEBT.system_jacobian!"><code>GEBT.system_jacobian!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">system_jacobian!(jacob, x, assembly, prescribed_conditions, distributed_loads,
	istep, irow_pt, irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam)
system_jacobian!(jacob, x, assembly, prescribed_conditions, distributed_loads,
	istep, irow_pt, irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam,
	x0, v0, ω0)
system_jacobian!(jacob, x, assembly, prescribed_conditions, distributed_loads,
	istep, irow_pt, irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam,
	x0, v0, ω0, u, θ, udot, θdot)
system_jacobian!(jacob, x, assembly, prescribed_conditions, distributed_loads,
	istep, irow_pt, irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam,
	x0, v0, ω0, udot_init, θdot_init, CtCabPdot_init, CtCabHdot_init, dt)</code></pre><p>Populate the jacobian matrix <code>jacob</code> with the jacobian of the residual vector with respect to the state variables.</p><p>There are four implementations corresponding to the following analysis types:</p><ul><li>Static</li><li>Dynamic - Steady State</li><li>Dynamic - Initial Step (for initializing time domain simulations)</li><li>Dynamic - Time Marching</li></ul><p>See &quot;GEBT: A general-purpose nonlinear analysis tool for composite beams&quot; by  Wenbin Yu and &quot;Geometrically nonlinear analysis of composite beams using  Wiener-Milenković parameters&quot; by Qi Wang and Wenbin Yu.</p><p><strong>Arguments</strong></p><ul><li><code>jacob</code>: Jacobian matrix</li><li><code>x</code>: Vector containing current state variables of the system</li><li><code>assembly</code>: Assembly of rigidly connected nonlinear beam elements</li><li><code>prescribed_conditions</code>: Dictionary of prescribed conditions at all time steps</li><li><code>distributed_loads</code>: Dictionary of distributed loads at all time steps</li><li><code>istep</code>: Current time step</li><li><code>irow_pt</code>: Row index of first equilibrium equation for each point</li><li><code>irow_beam</code>: Row index of first equation for just this beam element</li><li><code>irow_beam1</code>: Row index of first equation for the left side of each beam</li><li><code>irow_beam2</code>: Row index of first equation for the right side of each beam</li><li><code>icol_pt</code>: Column index of first state variable for each point</li><li><code>icol_beam</code>: Column index of first state variable for each beam element</li></ul><p><strong>Additional Arguments for Dynamic Analyses</strong></p><ul><li><code>x0</code>: Global frame origin (for the current time step)</li><li><code>v0</code>: Global frame linear velocity (for the current time step)</li><li><code>ω0</code>: Global frame angular velocity (for the current time step)</li></ul><p><strong>Additional Arguments for Initial Step Analyses</strong></p><ul><li><code>u</code>: deflection variables for each beam element</li><li><code>θ</code>: rotation variables for each beam element</li><li><code>udot</code>: time derivative of u for each beam element</li><li><code>θdot</code>: time derivative of θ for each beam element</li></ul><p><strong>Additional Arguments for Time Marching Analyses</strong></p><ul><li><code>udot</code>: <code>-2/dt*u - udot</code> for each beam element from the previous time step</li><li><code>θdot_init</code>: <code>-2/dt*θ - θdot</code> for each beam element from the previous time step</li><li><code>CtCabPdot</code>: <code>-2/dt*C&#39;*Cab*P - C&#39;*Cab*Pdot</code> for each beam element from the previous time step</li><li><code>CtCabHdot</code>: <code>-2/dt*C&#39;*Cab*H - C&#39;*Cab*Hdot</code> for each beam element from the previous time step</li><li><code>dt</code>: time step size</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/system.jl#L462-L519">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GEBT.system_mass_matrix!" href="#GEBT.system_mass_matrix!"><code>GEBT.system_mass_matrix!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">system_mass_matrix!(jacob, x, assembly, irow_pt, irow_beam, irow_beam1,
	irow_beam2, icol_pt, icol_beam)</code></pre><p>Populate the system &quot;mass matrix&quot;, the jacobian of the residual vector with respect to the time derivatives of the state variables.</p><p>See &quot;GEBT: A general-purpose nonlinear analysis tool for composite beams&quot; by Wenbin Yu and &quot;Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters&quot; by Qi Wang and Wenbin Yu.</p><p><strong>Arguments</strong></p><ul><li><code>jacob</code>: Jacobian matrix</li><li><code>x</code>: Vector containing current state variables of the system</li><li><code>assembly</code>: Assembly of rigidly connected nonlinear beam elements</li><li><code>irow_pt</code>: Row index of first equilibrium equation for each point</li><li><code>irow_beam</code>: Row index of first equation for just this beam element</li><li><code>irow_beam1</code>: Row index of first equation for the left side of each beam</li><li><code>irow_beam2</code>: Row index of first equation for the right side of each beam</li><li><code>icol_pt</code>: Column index of first state variable for each point</li><li><code>icol_beam</code>: Column index of first state variable for each beam element</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/GEBT.jl/blob/c268c2a5669cbea0faaaf979757552fd1ce5589c/src/system.jl#L690-L711">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#GEBT.Assembly"><code>GEBT.Assembly</code></a></li><li><a href="#GEBT.Assembly-Tuple{Any,Any,Any}"><code>GEBT.Assembly</code></a></li><li><a href="#GEBT.AssemblyState-Tuple{Any,Any}"><code>GEBT.AssemblyState</code></a></li><li><a href="#GEBT.AssemblyState"><code>GEBT.AssemblyState</code></a></li><li><a href="#GEBT.DistributedLoads-Tuple{Any,Any}"><code>GEBT.DistributedLoads</code></a></li><li><a href="#GEBT.DistributedLoads"><code>GEBT.DistributedLoads</code></a></li><li><a href="#GEBT.Element"><code>GEBT.Element</code></a></li><li><a href="#GEBT.ElementState"><code>GEBT.ElementState</code></a></li><li><a href="#GEBT.PointState"><code>GEBT.PointState</code></a></li><li><a href="#GEBT.PrescribedConditions-Tuple{}"><code>GEBT.PrescribedConditions</code></a></li><li><a href="#GEBT.PrescribedConditions"><code>GEBT.PrescribedConditions</code></a></li><li><a href="#GEBT.System-Tuple{Any,Any,Any}"><code>GEBT.System</code></a></li><li><a href="#GEBT.System"><code>GEBT.System</code></a></li><li><a href="#GEBT.curve_length"><code>GEBT.curve_length</code></a></li><li><a href="#GEBT.discretize_beam"><code>GEBT.discretize_beam</code></a></li><li><a href="#GEBT.dynamic_element_properties"><code>GEBT.dynamic_element_properties</code></a></li><li><a href="#GEBT.eigenvalue_analysis"><code>GEBT.eigenvalue_analysis</code></a></li><li><a href="#GEBT.eigenvalue_analysis!"><code>GEBT.eigenvalue_analysis!</code></a></li><li><a href="#GEBT.element_angular_velocity"><code>GEBT.element_angular_velocity</code></a></li><li><a href="#GEBT.element_curvature"><code>GEBT.element_curvature</code></a></li><li><a href="#GEBT.element_equations"><code>GEBT.element_equations</code></a></li><li><a href="#GEBT.element_jacobian!"><code>GEBT.element_jacobian!</code></a></li><li><a href="#GEBT.element_jacobian_equations"><code>GEBT.element_jacobian_equations</code></a></li><li><a href="#GEBT.element_linear_velocity"><code>GEBT.element_linear_velocity</code></a></li><li><a href="#GEBT.element_mass_matrix!"><code>GEBT.element_mass_matrix!</code></a></li><li><a href="#GEBT.element_mass_matrix_equations"><code>GEBT.element_mass_matrix_equations</code></a></li><li><a href="#GEBT.element_mass_matrix_properties"><code>GEBT.element_mass_matrix_properties</code></a></li><li><a href="#GEBT.element_properties"><code>GEBT.element_properties</code></a></li><li><a href="#GEBT.element_residual!"><code>GEBT.element_residual!</code></a></li><li><a href="#GEBT.element_strain"><code>GEBT.element_strain</code></a></li><li><a href="#GEBT.get_C"><code>GEBT.get_C</code></a></li><li><a href="#GEBT.get_C_c"><code>GEBT.get_C_c</code></a></li><li><a href="#GEBT.get_C_cdot"><code>GEBT.get_C_cdot</code></a></li><li><a href="#GEBT.get_C_t"><code>GEBT.get_C_t</code></a></li><li><a href="#GEBT.get_Q"><code>GEBT.get_Q</code></a></li><li><a href="#GEBT.get_Q_c"><code>GEBT.get_Q_c</code></a></li><li><a href="#GEBT.get_Qinv"><code>GEBT.get_Qinv</code></a></li><li><a href="#GEBT.get_Qinv_c"><code>GEBT.get_Qinv_c</code></a></li><li><a href="#GEBT.insert_element_jacobian!"><code>GEBT.insert_element_jacobian!</code></a></li><li><a href="#GEBT.insert_element_mass_matrix!"><code>GEBT.insert_element_mass_matrix!</code></a></li><li><a href="#GEBT.insert_element_residual!"><code>GEBT.insert_element_residual!</code></a></li><li><a href="#GEBT.insert_point_jacobian!"><code>GEBT.insert_point_jacobian!</code></a></li><li><a href="#GEBT.insert_point_residual!"><code>GEBT.insert_point_residual!</code></a></li><li><a href="#GEBT.left_eigenvectors"><code>GEBT.left_eigenvectors</code></a></li><li><a href="#GEBT.mul3"><code>GEBT.mul3</code></a></li><li><a href="#GEBT.point_connections"><code>GEBT.point_connections</code></a></li><li><a href="#GEBT.point_follower_jacobians"><code>GEBT.point_follower_jacobians</code></a></li><li><a href="#GEBT.point_jacobian!"><code>GEBT.point_jacobian!</code></a></li><li><a href="#GEBT.point_residual!"><code>GEBT.point_residual!</code></a></li><li><a href="#GEBT.point_variables"><code>GEBT.point_variables</code></a></li><li><a href="#GEBT.static_analysis"><code>GEBT.static_analysis</code></a></li><li><a href="#GEBT.static_analysis!"><code>GEBT.static_analysis!</code></a></li><li><a href="#GEBT.steady_state_analysis"><code>GEBT.steady_state_analysis</code></a></li><li><a href="#GEBT.steady_state_analysis!"><code>GEBT.steady_state_analysis!</code></a></li><li><a href="#GEBT.system_indices"><code>GEBT.system_indices</code></a></li><li><a href="#GEBT.system_jacobian!"><code>GEBT.system_jacobian!</code></a></li><li><a href="#GEBT.system_mass_matrix!"><code>GEBT.system_mass_matrix!</code></a></li><li><a href="#GEBT.system_residual!"><code>GEBT.system_residual!</code></a></li><li><a href="#GEBT.tilde"><code>GEBT.tilde</code></a></li><li><a href="#GEBT.time_domain_analysis"><code>GEBT.time_domain_analysis</code></a></li><li><a href="#GEBT.time_domain_analysis!"><code>GEBT.time_domain_analysis!</code></a></li><li><a href="#GEBT.wiener_milenkovic"><code>GEBT.wiener_milenkovic</code></a></li><li><a href="#GEBT.write_vtk"><code>GEBT.write_vtk</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">« Examples</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 31 July 2020 22:16">Friday 31 July 2020</span>. Using Julia version 1.4.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
