var documenterSearchIndex = {"docs":
[{"location":"library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Pages = [\"library.md\"]\nDepth = 3","category":"page"},{"location":"library/#Public-API","page":"Library","title":"Public API","text":"","category":"section"},{"location":"library/#Creating-an-Assembly","page":"Library","title":"Creating an Assembly","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"curve_length\ndiscretize_beam\nAssembly(points, start, stop)","category":"page"},{"location":"library/#GEBT.curve_length","page":"Library","title":"GEBT.curve_length","text":"curve_length(r1, r2, k)\n\nCalculate the length of a curve given its endpoints and its curvature vector\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.discretize_beam","page":"Library","title":"GEBT.discretize_beam","text":"discretize_beam(L, r, d; Cab = Matrix(I,3,3)), k = zeros(3))\n\nDiscretize a beam according to the discretization provided in d, an array that ranges from 0 to 1, with 0 representing the beginning of the beam and 1 representing the end of the beam.\n\nIf d is an integer, the beam is discretized into d uniformly spaced elements.\n\nReturn the lengths, endpoints, midpoints, and rotation matrices of the beam elements.\n\nArguments\n\nL: Beam length\nr: Beam starting point\nd: Discretization vector\nCab: 3x3 beam rotation matrix at the starting point\nk: curvature vector\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.Assembly-Tuple{Any,Any,Any}","page":"Library","title":"GEBT.Assembly","text":"Assembly(points, start, stop; kwargs...)\n\nConstruct an assembly of connected nonlinear beam elements for analysis.  Beam lengths and midpoints may be manually specified in case beam elements are curved rather than straight.\n\nArguments\n\npoints: Array of all beam element endpoints\nstart: Array containing point index where each beam element starts\nstop: Array containing point index where each beam element stops\n\nKeyword Arguments\n\nstiffness: Array of (6 x 6) stiffness matrices for each beam element, alternative to providing compliance\ncompliance: Array of (6 x 6) compliance matrices for each beam element, defaults to zeros(6,6) for each beam element\nmass: Array of (6 x 6) mass matrices for each beam element, alternative to providing minv\nminv: Array of (6 x 6) mass matrices for each beam element, defaults to the identity matrix for each beam element\nframes: Array of (3 x 3) direction cosine matrices for each beam element, defaults to the identity matrix for each beam element\nlengths: Array containing the length of each beam, defaults to the distance between beam endpoints\nmidpoints: Array containing the midpoint of each beam element, defaults to the average of the beam element endpoints\n\n\n\n\n\n","category":"method"},{"location":"library/#Defining-Prescribed-Conditions","page":"Library","title":"Defining Prescribed Conditions","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"PrescribedConditions()\nDistributedLoads(assembly, ibeam)","category":"page"},{"location":"library/#GEBT.PrescribedConditions-Tuple{}","page":"Library","title":"GEBT.PrescribedConditions","text":"PrescribedConditions(dt=0.0; kwargs...)\n\nConstruct an object of type PrescribedConditions which stores the prescribed conditions for a point at each time step.\n\nPrescribed conditions may be assigned as either a scalar parameter or as a function of time.\n\nArguments\n\ndt: Time step size.\nnstep: The total length of the time vector\nux: Prescribed x-direction displacement of the point\nuy: Prescribed y-direction displacement of the point\nuz: Prescribed z-direction displacement of the point\ntheta_x: Prescribed first Wiener-Milenkovic parameter of the point\ntheta_y: Prescribed second Wiener-Milenkovic parameter of the point\ntheta_z: Prescribed third Wiener-Milenkovic parameter of the point\nFx: Prescribed force in x-direction applied on the point\nFy: Prescribed force in y-direction applied on the point\nFz: Prescribed force in z-direction applied on the point\nMx: Prescribed moment about x-axis applied on the point\nMy: Prescribed moment about y-axis applied on the point\nMz: Prescribed moment about z-axis applied on the point\nFx_follower: Prescribed follower force in x-direction applied on the point\nFy_follower: Prescribed follower force in y-direction applied on the point\nFz_follower: Prescribed follower force in z-direction applied on the point\nMx_follower: Prescribed follower moment about x-axis applied on the point\nMy_follower: Prescribed follower moment about y-axis applied on the point\nMz_follower: Prescribed follower moment about z-axis applied on the point\n\n\n\n\n\n","category":"method"},{"location":"library/#GEBT.DistributedLoads-Tuple{Any,Any}","page":"Library","title":"GEBT.DistributedLoads","text":"DistributedLoads(assembly, ibeam[, dt]; kwargs...)\n\nIntegrates the specified distributed loads over the element for each time step.\n\nArguments\n\nΔL: The length of the beam element\ndt: Time step size.  If omitted a single time step is assumed and specified\n\nfunctions become a function of s only.\n\ns1 = 0.0: Start of beam element\ns2 = 1.0: End of beam element\nnstep: The total length of the time vector\nmethod = (f, a, b) -> trapz(range(a, b, length=100), f.(range(a, b, length=100))):  Method to use for integrating over the elements.  Defaults to the trapezoidal\n\nmethod with 100 points.\n\nfx = (s, t) -> 0.0: Distributed non-follower force on beam element in x-direction\nfy = (s, t) -> 0.0: Distributed non-follower force on beam element in y-direction\nfz = (s, t) -> 0.0: Distributed non-follower force on beam element in z-direction\nmx = (s, t) -> 0.0: Distributed non-follower moment on beam element in x-direction\nmy = (s, t) -> 0.0: Distributed non-follower moment on beam element in y-direction\nmz = (s, t) -> 0.0: Distributed non-follower moment on beam element in z-direction\nfx_follower = (s, t) -> 0.0: Distributed follower force on beam element in x-direction\nfy_follower = (s, t) -> 0.0: Distributed follower force on beam element in y-direction\nfz_follower = (s, t) -> 0.0: Distributed follower force on beam element in z-direction\nmx_follower = (s, t) -> 0.0: Distributed follower moment on beam element in x-direction\nmy_follower = (s, t) -> 0.0: Distributed follower moment on beam element in y-direction\nmz_follower = (s, t) -> 0.0: Distributed follower moment on beam element in z-direction\n\n\n\n\n\n","category":"method"},{"location":"library/#Pre-Initializing-Memory-for-an-Analysis","page":"Library","title":"Pre-Initializing Memory for an Analysis","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"System(assembly, points, static)","category":"page"},{"location":"library/#GEBT.System-Tuple{Any,Any,Any}","page":"Library","title":"GEBT.System","text":"System([TF=eltype(assembly),] assembly, points, static)\n\nInitialize an object of type System which stores the system state, residual vector, current time function values,and jacobian matrices as well as pointers to be able to access their contents.\n\nArguments:\n\nTF: (optional) Used to specify floating point type used by resulting System object\nassembly: Assembly of rigidly connected nonlinear beam elements\npoints: Point indices which should be preserved in the system of equations\nstatic: Flag indicating whether system matrices will be used only for static simulations\n\n\n\n\n\n","category":"method"},{"location":"library/#Performing-an-Analysis","page":"Library","title":"Performing an Analysis","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"static_analysis\nstatic_analysis!\nsteady_state_analysis\nsteady_state_analysis!\neigenvalue_analysis\neigenvalue_analysis!\ntime_domain_analysis\ntime_domain_analysis!","category":"page"},{"location":"library/#GEBT.static_analysis","page":"Library","title":"GEBT.static_analysis","text":"static_analysis(assembly; kwargs...)\n\nPerform a static analysis of the system of nonlinear beams contained in assembly. Return the resulting system and a flag indicating whether the iteration procedure converged.\n\nKeyword Arguments\n\nprescribed_conditions=Dict{Int,PrescribedConditions{Float64}}(): Dictionary\n\nholding PrescribedConditions composite types for the points in keys(prescribed_conditions)\n\ndistributed_loads=Dict{Int,DistributedLoads{Float64}}(): Dictionary holding\n\nDistributedLoads composite types for the beam elements in keys(distributed_loads)\n\nlinear=false: Set to true for a linear analysis\nmethod=:newton: Method (as defined in NLsolve) to solve nonlinear system of equations\nlinesearch=LineSearches.BackTracking(): Line search used to solve nonlinear system of equations\nftol=1e-12: tolerance for solving nonlinear system of equations\niterations=1000: maximum iterations for solving the nonlinear system of equations\nnstep=1: Number of time steps. May be used in conjunction with time varying\n\nprescribed conditions and distributed loads to gradually increase \tdisplacements/loads.\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.static_analysis!","page":"Library","title":"GEBT.static_analysis!","text":"static_analysis!(system, assembly; kwargs...)\n\nPre-allocated version of static_analysis.\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.steady_state_analysis","page":"Library","title":"GEBT.steady_state_analysis","text":"steady_state_analysis(assembly; kwargs...)\n\nPerform a steady-state analysis for the system of nonlinear beams contained in assembly.  Return the resulting system and a flag indicating whether the iteration procedure converged.\n\nKeyword Arguments\n\nprescribed_conditions=Dict{Int,PrescribedConditions{Float64}}(): Dictionary\n\nholding PrescribedConditions composite types for the points in keys(prescribed_conditions)\n\ndistributed_loads=Dict{Int,DistributedLoads{Float64}}(): Dictionary holding\n\nDistributedLoads composite types for the beam elements in keys(distributed_loads)\n\nlinear=false: Set to true for a linear analysis\nmethod=:newton: Method (as defined in NLsolve) to solve nonlinear system of equations\nlinesearch=LineSearches.BackTracking(): Line search used to solve nonlinear system of equations\nftol=1e-12: tolerance for solving nonlinear system of equations\niterations=1000: maximum iterations for solving the nonlinear system of equations\nnstep=1: Number of time steps. May be used in conjunction with time varying\n\nprescribed conditions, distributed loads, and global motion to gradually \tincrease displacements/loads.\n\norigin = zeros(3): Global frame origin\nlinear_velocity = fill(zeros(3), nstep): Global frame linear velocity for each time step.\nangular_velocity = fill(zeros(3), nstep): Global frame angular velocity for each time step\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.steady_state_analysis!","page":"Library","title":"GEBT.steady_state_analysis!","text":"steady_state_analysis!(system, assembly; kwargs...)\n\nPre-allocated version of steady_state_analysis\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.eigenvalue_analysis","page":"Library","title":"GEBT.eigenvalue_analysis","text":"eigenvalue_analysis(assembly; kwargs...)\n\nCompute the eigenvalues and eigenvectors of the system of nonlinear beams contained in assembly by calling ARPACK.  Return the modified system, eigenvalues, eigenvectors, and a convergence flag indicating whether the corresponding steady-state analysis converged.\n\nKeyword Arguments\n\nprescribed_conditions=Dict{Int,PrescribedConditions{Float64}}(): Dictionary\n\nholding PrescribedConditions composite types for the points in keys(prescribed_conditions)\n\ndistributed_loads=Dict{Int,DistributedLoads{Float64}}(): Dictionary holding\n\nDistributedLoads composite types for the beam elements in keys(distributed_loads)\n\nlinear=false: Set to true for a linear analysis\nmethod = :newton: Method (as defined in NLsolve) to solve nonlinear system of equations\nlinesearch = LineSearches.BackTracking(): Line search used to solve nonlinear system of equations\nftol = 1e-12: tolerance for solving nonlinear system of equations\niterations = 1000: maximum iterations for solving the nonlinear system of equations\nnstep=1: Number of time steps. May be used in conjunction with time varying\n\nprescribed conditions, distributed loads, and global motion to gradually \tincrease displacements/loads.\n\norigin = zeros(3): Global frame origin\nlinear_velocity = fill(zeros(3), nstep): Global frame linear velocity for each time step.\nangular_velocity = fill(zeros(3), nstep): Global frame angular velocity for each time step\nnev = 6: Number of eigenvalues to compute\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.eigenvalue_analysis!","page":"Library","title":"GEBT.eigenvalue_analysis!","text":"eigenvalue_analysis!(system, assembly; kwargs...)\n\nPre-allocated version of eigenvalue_analysis.\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.time_domain_analysis","page":"Library","title":"GEBT.time_domain_analysis","text":"time_domain_analysis(assembly, dt; kwargs...)\n\nPerform a time-domain analysis for the system of nonlinear beams contained in assembly.  Return the final system, a post-processed solution history, and a convergence flag indicating whether the iterations converged for each time step.\n\nKeyword Arguments\n\nprescribed_conditions = Dict{Int,PrescribedConditions{Float64}}(): Dictionary\n\nholding PrescribedConditions composite types for the points in keys(prescribed_conditions)\n\ndistributed_loads = Dict{Int,DistributedLoads{Float64}}(): Dictionary holding\n\nDistributedLoads composite types for the beam elements in keys(distributed_loads)\n\nlinear=false: Set to true for a linear analysis\nmethod=:newton: Method (as defined in NLsolve) to solve nonlinear system of equations\nlinesearch=LineSearches.BackTracking(): Line search used to solve nonlinear system of equations\nftol=1e-12: tolerance for solving nonlinear system of equations\niterations=1000: maximum iterations for solving the nonlinear system of equations\nnstep=1: The total length of the time vector\norigin = zeros(3): Global frame origin\nlinear_velocity = fill(zeros(3), nstep): Global frame linear velocity for each time step.\nangular_velocity = fill(zeros(3), nstep): Global frame angular velocity for each time step.\nu0=fill(zeros(3), length(assembly.elements)): initial displacment of each beam element,\ntheta0=fill(zeros(3), length(assembly.elements)): initial angular displacement of each beam element,\nudot0=fill(zeros(3), length(assembly.elements)): initial time derivative with respect to u\nthetadot0=fill(zeros(3), length(assembly.elements)): initial time derivative with respect to theta\nsave=1:nstep: Steps at which to save the time history\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.time_domain_analysis!","page":"Library","title":"GEBT.time_domain_analysis!","text":"time_domain_analysis!(system, assembly, dt; kwargs...)\n\nPre-allocated version of time_domain_analysis.\n\n\n\n\n\n","category":"function"},{"location":"library/#Post-Processing","page":"Library","title":"Post-Processing","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"AssemblyState(system, assembly)\nAssemblyState\nleft_eigenvectors\ncorrelate_eigenmodes\nwiener_milenkovic\nwrite_vtk","category":"page"},{"location":"library/#GEBT.AssemblyState-Tuple{Any,Any}","page":"Library","title":"GEBT.AssemblyState","text":"AssemblyState(system, assembly, x = system.x;\n\tprescribed_conditions = Dict{Int,PrescribedConditions{Float64}}())\n\nPost-process the system state given the solution vector x.  Return an object of type AssemblyState that defines the state of the assembly for the time step.\n\nIf prescribed_conditions is not provided, all point state variables are assumed to be displacements/rotations, rather than their actual identities as used in the analysis.\n\n\n\n\n\n","category":"method"},{"location":"library/#GEBT.AssemblyState","page":"Library","title":"GEBT.AssemblyState","text":"AssemblyState{TF, TP<:AbstractVector{PointState{TF}}, TE<:AbstractVector{ElementState{TF}}}\n\nStruct for storing state variables for the points and elements in an assembly.\n\nFields:\n\npoints::TP: Array of PointStates for each point in the assembly\nelements::TE: Array of ElementStates for each element in the assembly\n\n\n\n\n\n","category":"type"},{"location":"library/#GEBT.left_eigenvectors","page":"Library","title":"GEBT.left_eigenvectors","text":"left_eigenvectors(system, λ, V)\nleft_eigenvectors(K, M, λ, V)\n\nCompute the left eigenvector matrix Us for the system using inverse power iteration given the eigenvalues λ and the corresponding right eigenvector matrix V.\n\nThe complex conjugate of each left eigenvector is stored in each row of the matrix Us\n\nLeft and right eigenvectors satisfy the following M-orthogonality condition:\n\nu'Mv = 1 if u and v correspond to the same eigenvalue\nu'Mv = 0 if u and v correspond to different eigenvalues\n\nThis function assumes that system has not been modified since the eigenvalues and right eigenvectors were computed.\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.correlate_eigenmodes","page":"Library","title":"GEBT.correlate_eigenmodes","text":"correlate_eigenmodes(C)\n\nReturn the permutation and the associated corruption index vector which associates eigenmodes from the currrent iteration with those of the previous iteration given the correlation matrix C.\n\nThe correlation matrix can take one of the following forms (in order of preference):\n\nC = U_p*M*V\nC = U*M_p*V_p\nC = V_p'*V\nC = V'*V_p\n\nwhere U is a matrix of conjugated left eigenvectors, M is the system mass matrix, V is a matrix of right eigenvectors, and ()_p indicates a variable from the previous iteration.\n\nThe corruption index is the largest magnitude in a given row/column of C that was not chosen divided by the magnitude of the chosen eigenmode.  It is most meaningful when using one of the two first forms of the correlation matrix since correct eigenmodes will have magnitudes close to 1 and incorrect eigenmodes will have magnitudes close to 0.\n\nIf the new mode number is already assigned the next highest unassigned mode number is used.  In this case a corruption index higher than 1 will be returned, otherwise the values of the corruption index will always be bounded by 0 and 1.\n\nSee \"New Mode Tracking Methods in Aeroelastic Analysis\" by Eldred, Vankayya, and Anderson.\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.wiener_milenkovic","page":"Library","title":"GEBT.wiener_milenkovic","text":"wiener_milenkovic(c)\n\nConstruct a Wiener-Milenkovic rotation matrix, given the three Wiener-Milenkovic rotation parameters in c.\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.write_vtk","page":"Library","title":"GEBT.write_vtk","text":"write_vtk(name, assembly::Assembly [, state::AssemblyState]; kwargs...)\n\nWrite the deformed geometry (and associated data) to a VTK file for visualization using ParaView.\n\nThe state parameter may be omitted to write the original geometry to a VTK file without any associated data.\n\nKeyword Arguments\n\nscaling=1.0: Parameter to scale the deflections\nmetadata=Dict(): Dictionary of metadata for the file\n\n\n\n\n\nwrite_vtk(name, assembly::Assembly, [state::AssemblyState, ]λ::Number, eigenstate::AssemblyState;\nscaling=1.0, mode_scaling=1.0, cycles=1, steps=100)\n\nWrite a series of files corresponding to the elastic motion of the assembly about the deformed state encoded in state defined by the eigenvalue λ and the eigenvector encoded in eigenstate over the time period specified by time.\n\nThe steady-state deflections can be scaled with scaling and the eigenmode deflections can be scaled using mode_scaling.\n\nThe current time is encoded in the metadata tag \"time\"\n\n\n\n\n\n","category":"function"},{"location":"library/#Private-API","page":"Library","title":"Private API","text":"","category":"section"},{"location":"library/#Math","page":"Library","title":"Math","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"GEBT.tilde\nGEBT.get_C\nGEBT.get_C_t\nGEBT.get_C_c\nGEBT.get_C_cdot\nGEBT.get_Q\nGEBT.get_Q_c\nGEBT.get_Qinv\nGEBT.get_Qinv_c\nGEBT.mul3","category":"page"},{"location":"library/#GEBT.tilde","page":"Library","title":"GEBT.tilde","text":"tilde(x)\n\nConstruct the cross product operator matrix\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.get_C","page":"Library","title":"GEBT.get_C","text":"get_C(c)\n\nAlias for wiener_milenkovic(c)\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.get_C_t","page":"Library","title":"GEBT.get_C_t","text":"get_C_t([C, ] c, c_t)\n\nCalculate the derivative of a Wiener-Milenkovic rotation matrix C with respect to the scalar parameter t. c_t is the derivative of c with respect to t.\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.get_C_c","page":"Library","title":"GEBT.get_C_c","text":"get_C_c([C, ] c)\n\nCalculate the derivative of the Wiener-Milenkovic rotation matrix C with respect to each of the rotation parameters in c.\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.get_C_cdot","page":"Library","title":"GEBT.get_C_cdot","text":"get_C_cdot([C, ] c)\n\nCalculate the derivative of the time derivative of the Wiener-Milenkovic rotation matrix C with respect to each of the time derivatives of c. Used for constructing the \"mass\" matrix for eigenvalue computations.\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.get_Q","page":"Library","title":"GEBT.get_Q","text":"get_Q(c)\n\nCalculate the matrix Q as defined in the paper \"Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters\" by Qi Wang and Wenbin Yu.\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.get_Q_c","page":"Library","title":"GEBT.get_Q_c","text":"get_Q_c(c)\nget_Q_c(Q, c)\n\nCalculate the derivative of the matrix Q with respect to each of the rotation parameters in c.\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.get_Qinv","page":"Library","title":"GEBT.get_Qinv","text":"get_Qinv(c)\n\nCalculate the matrix inverse Qinv as defined in the paper \"Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters\" by Qi Wang and Wenbin Yu.\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.get_Qinv_c","page":"Library","title":"GEBT.get_Qinv_c","text":"get_Qinv_c(c)\n\nCalculate the derivative of the matrix inverse Qinv with respect to each of the rotation parameters in c.\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.mul3","page":"Library","title":"GEBT.mul3","text":"mul3(A_1, A_2, A_3, b)\n\nReturns the product of a 3x3x3 tensor represented by A_1, A_2, and A_3 with the vector b.\n\n\n\n\n\n","category":"function"},{"location":"library/#Points","page":"Library","title":"Points","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"GEBT.point_variables\nGEBT.insert_point_residual!\nGEBT.point_residual!\nGEBT.point_follower_jacobians\nGEBT.insert_point_jacobian!\nGEBT.point_jacobian!\nGEBT.PointState","category":"page"},{"location":"library/#GEBT.point_variables","page":"Library","title":"GEBT.point_variables","text":"point_variables(x, icol)\npoint_variables(x, icol, prescribed_conditions, istep)\n\nExtract u, θ, F, M for the point described by the point state variables at icol in x after incorporating the prescribed conditions in prescribed_conditions\n\nNote that the degrees of freedom that are not specified in prescribed_conditions are used as state variables (e.g. prescribing F[2] would mean u[2] = x[icol+1])\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.insert_point_residual!","page":"Library","title":"GEBT.insert_point_residual!","text":"insert_point_residual!(resid, irow_b, irow_p, u, θ, F, M, side)\n\nModify the equilibrium and constitutive equations to account for the point variables given by u, θ, F, M\n\nIf irowb != irowp, assume that the equilibrium equations have already been modified\n\nArguments\n\nresid: Residual vector\nirow_b: Row index of the first equilibrium/compatability equation for one side of the beam element\nirow_p: Row index of the first equilibrium equation for the point\nu: Displacement of the point\nθ: Rotation of the point\nF: External forces imposed on the point\nM: External moments imposed on the point\nside: Side of beam (-1 (left) or 1 (right))\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.point_residual!","page":"Library","title":"GEBT.point_residual!","text":"point_residual!(resid, x, ipoint, assembly, prescribed_conditions, icol,\n\tirow_p, irow_beam1, irow_beam2)\n\nAdds a points contributions to the residual vector\n\nArguments\n\nresid: residual vector\nx: current state vector\nipoint: index of point\nassembly: assembly of interconnected beam elements\nprescribed_conditions: dictionary of prescribed conditions\nicol: starting index for the point's state variables\nirow_p: Row index of the first equilibrium equation for the point\nirow_beam1: Row index of first equation for the left side of each beam\nirow_beam2: Row index of first equation for the right side of each beam\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.point_follower_jacobians","page":"Library","title":"GEBT.point_follower_jacobians","text":"point_follower_jacobians(x, icol, prescribed_conditions)\n\nCalculate the jacobians of the follower forces/moments with respect to θ\n\nArguments\n\nx: Current state variable vector\nicol: Row/Column index of the first state variable for the point\nprescribed_conditions: Prescribed conditions for the point\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.insert_point_jacobian!","page":"Library","title":"GEBT.insert_point_jacobian!","text":"insert_point_jacobian!(jacob, irow_b, irow_p, icol, prescribed_conditions, side, F_θ, M_θ)\n\nModify the jacobian entries for the equilibrium and constitutive equations to account for the point variables at icol\n\nIf irowb != irowp, assume that the equilibrium equations have already been modified\n\nArguments\n\njacob: Jacobian of residual vector with respect to state vectors\nirow_b: Row index of the first equilibrium/compatability equation for one side of the beam element\nirow_p: Row index of the first equilibrium equation for the point\nicol: Row/Column index of the first state variable for the point\nprescribed_conditions: Prescribed force/displacement and moment/rotation on point\nside: Side of beam (-1 (left) or 1 (right))\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.point_jacobian!","page":"Library","title":"GEBT.point_jacobian!","text":"point_jacobian!(jacob, x, ipoint, assembly, prescribed_conditions, icol,\n\tirow_p, irow_beam1, irow_beam2)\n\nAdds a points contributions to the residual vector\n\nArguments\n\njacob: residual vector\nx: current state vector\nipoint: index of point\nassembly: assembly of interconnected beam elements\nprescribed_conditions: dictionary of prescribed conditions\nistep: current time step\nicol: starting index for the point's state variables\nirow_p: Row index of the first equilibrium equation for the point\nirow_beam1: Row index of first equation for the left side of each beam\nirow_beam2: Row index of first equation for the right side of each beam\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.PointState","page":"Library","title":"GEBT.PointState","text":"PointState\n\nHolds the state variables for a point\n\nFields:\n\nu: Displacement variables for the point\ntheta: Wiener-Milenkovic rotation variables for the point\nF: Externally applied forces on the point\nM: Externally applied moments on the point\n\n\n\n\n\n","category":"type"},{"location":"library/#Elements","page":"Library","title":"Elements","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"GEBT.Element\nGEBT.element_strain\nGEBT.element_curvature\nGEBT.element_linear_velocity\nGEBT.element_angular_velocity\nGEBT.element_properties\nGEBT.dynamic_element_properties\nGEBT.element_equations\nGEBT.insert_element_residual!\nGEBT.element_residual!\nGEBT.element_jacobian_equations\nGEBT.insert_element_jacobian!\nGEBT.element_jacobian!\nGEBT.element_mass_matrix_properties\nGEBT.element_mass_matrix_equations\nGEBT.insert_element_mass_matrix!\nGEBT.element_mass_matrix!\nGEBT.ElementState","category":"page"},{"location":"library/#GEBT.Element","page":"Library","title":"GEBT.Element","text":"Element{TF}\n\nComposite type that defines a beam element's properties\n\nFields\n\nL: Length of the beam element\nx: Location of the beam element (the midpoint of the beam element)\nC11: Upper left portion of the beam element's compliance matrix\nC12: Upper right portion of the beam element's compliance matrix\nC22: Lower right portion of the beam element's compliance matrix\nminv11: Upper left portion of the inverse of the beam element's mass matrix\nminv12: Upper right portion of the inverse of the beam element's mass matrix\nminv22: Lower right portion of the inverse of the beam element's mass matrix\nCab: Rotation matrix from the global frame to beam element's frame\n\n\n\n\n\n","category":"type"},{"location":"library/#GEBT.element_strain","page":"Library","title":"GEBT.element_strain","text":"element_strain(element, F, M)\n\nCalculate the strain of a beam element given the resultant force and moments\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.element_curvature","page":"Library","title":"GEBT.element_curvature","text":"element_curvature(element, F, M)\n\nCalculate the curvature of a beam element given the resultant force and moments\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.element_linear_velocity","page":"Library","title":"GEBT.element_linear_velocity","text":"element_linear_velocity(element, P, H)\n\nCalculate the linear velocity of a beam element given the linear and angular momenta\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.element_angular_velocity","page":"Library","title":"GEBT.element_angular_velocity","text":"element_angular_velocity(element, P, H)\n\nCalculate the angular velocity of a beam element given the linear and angular momenta\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.element_properties","page":"Library","title":"GEBT.element_properties","text":"element_properties(x, icol, beam)\nelement_properties(x, icol, beam, x0, v0, ω0)\nelement_properties(x, icol, ibeam, beam, x0, v0, ω0, u, θ, udot, θdot)\nelement_properties(x, icol, ibeam, beam, x0, v0, ω0, udot, θdot_init, CtCabPdot, CtCabHdot, dt)\n\nExtract/calculate the properties of a specific beam element.\n\nThere are four implementations corresponding to the following analysis types:\n\nStatic\nDynamic - Steady State\nDynamic - Initial Step (for initializing time domain simulations)\nDynamic - Time Marching\n\nSee \"GEBT: A general-purpose nonlinear analysis tool for composite beams\" by Wenbin Yu and \"Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters\" by Qi Wang and Wenbin Yu.\n\nArguments\n\nx: current state vector\nicol: starting index for the beam's state variables\nibeam: beam element index\nbeam: beam element\n\nAdditional Arguments for Dynamic Analyses\n\nx0: Global frame origin (for the current time step)\nv0: Global frame linear velocity (for the current time step)\nω0: Global frame angular velocity (for the current time step)\n\nAdditional Arguments for Initial Step Analyses\n\nu: deflection variables for each beam element\nθ: rotation variables for each beam element\nudot: time derivative of u for each beam element\nθdot: time derivative of θ for each beam element\n\nAdditional Arguments for Time Marching Analyses\n\nudot_init: 2/dt*u + udot for each beam element from the previous time step\nθdot_init: 2/dt*θ + θdot for each beam element from the previous time step\nCtCabPdot_init: 2/dt*C'*Cab*P + C'*Cab*Pdot for each beam element from the previous time step\nCtCabHdot_init: 2/dt*C'*Cab*H + C'*Cab*Hdot for each beam element from the previous time step\ndt: time step size\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.dynamic_element_properties","page":"Library","title":"GEBT.dynamic_element_properties","text":"dynamic_element_properties(x, icol, beam, x0, v0, ω0)\n\nExtract/Compute v, ω, P, H, V, and Ω.\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.element_equations","page":"Library","title":"GEBT.element_equations","text":"element_equations(ΔL, Cab, CtCab, u, θ, F, M, γ, κ)\nelement_equations(ΔL, Cab, CtCab, u, θ, F, M, γ, κ, v, ω, P, H, V, Ω)\nelement_equations(ΔL, Cab, CtCab, u, θ, F, M, γ, κ, v, ω, P, H, V, Ω,\n\tudot, θdot, CtCabPdot, CtCabHdot)\n\nEvaluate the nonlinear equations for a beam element.\n\nThere are three implementations corresponding to the following analysis types:\n\nStatic\nDynamic - Steady State\nDynamic - Initial Step or Time Marching\n\nSee \"GEBT: A general-purpose nonlinear analysis tool for composite beams\" by Wenbin Yu and \"Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters\" by Qi Wang and Wenbin Yu.\n\nArguments:\n\nΔL: Length of the beam element\nCt: Rotation tensor of the beam deformation in the \"a\" frame, transposed\nCab: Direction cosine matrix from \"a\" to \"b\" frame for the element\nCtCab: C'*Cab, precomputed for efficiency\nu: Displacement variables for the element [u1, u2, u3]\nθ: Rotation variables for the element [θ1, θ2, θ3]\nF: Force variables for the element [F1, F2, F3]\nM: Moment variables for the element [M1, M2, M3]\nγ: Engineering strains in the element [γ11, 2γ12, 2γ13]\nκ: Curvatures in the element [κ1, κ2, κ3]\n\nAdditional Arguments for Dynamic Analyses\n\nv: Linear velocity of element in global frame \"a\" [v1, v2, v3]\nω: Angular velocity of element in global frame \"a\" [ω1, ω2, ω3]\nP: Linear momenta for the element [P1, P2, P3]\nH: Angular momenta for the element [H1, H2, H3]\nV: Velocity of the element\nΩ: Rotational velocity of the element\n\nAdditional Arguments for Initial Step Analysis\n\nudot: user-specified time derivative of u\nθdot: user-specified time derivative of θ\nCtCabPdot: C'CabPdot state variable\nCtCabHdot: C'CabHdot state variable\n\nAdditional Arguments for Time Marching Analysis\n\nudot: 2/dt*(u-u_p) - udot_p for this beam element where _p denotes values\n\ntaken from the previous time step\n\nθdot: 2/dt*(θ-θ_p) - θdot_p for this beam element where _p denotes values\n\ntaken from the previous time step\n\nCtCabPdot: 2/dt*(C'*Cab*P - (C'*Cab*P)_p) - (C'*Cab*Pdot)_p for this beam\n\nelement where _p denotes values taken from the previous time step\n\nCtCabHdot: 2/dt*(C'*Cab*H - (C'*Cab*H)_p) - (C'*Cab*Hdot)_p for this beam\n\nelement where _p denotes values taken from the previous time step\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.insert_element_residual!","page":"Library","title":"GEBT.insert_element_residual!","text":"insert_element_residual!(resid, irow_b, irow_b1, irow_p1, irow_b2, irow_p2, f_u1, f_u2, f_ψ1,\n\tf_ψ2, f_F1, f_F2, f_M1, f_M2)\ninsert_element_residual!(resid, irow_b, irow_b1, irow_p1, irow_b2, irow_p2, f_u1, f_u2, f_ψ1,\n\tf_ψ2, f_F1, f_F2, f_M1, f_M2, f_P, f_H)\n\nInsert beam element resultants into the residual equation.  Initialize equilibrium and constitutive equations if they are not yet initialized.\n\nIf irow_b1 != irow_p1 and/or irow_b2 != irow_p2, assume the equilibrium equations for the left and/or right side are already initialized\n\nThere are two implementations corresponding to the following analysis types:\n\nStatic\nDynamic - Steady State, Initial Step, or Time Marching\n\nArguments\n\nresid: System residual vector\nirow_b1: Row index of the first equation for the left side of the beam element  (a value <= 0 indicates the equations have been eliminated from the system of equations)\nirow_p1: Row index of the first equation for the point on the left side of the beam element\nirow_b1: Row index of the first equation for the right side of the beam element\n\n(a value <= 0 indicates the equations have been eliminated from the system of equations)\n\nirow_p2: Row index of the first equation for the point on the right side of the beam element\nf_u1, f_u2: Resultant displacements for the left and right side of the beam element, respectively\nf_ψ1, f_ψ2: Resultant rotations for the left and right side of the beam element, respectively\nf_F1, f_F2: Resultant forces for the left and right side of the beam element, respectively\nf_M1, f_M2: Resultant moments for the left and right side of the beam element, respectively\n\nAdditional Arguments for Dynamic Analyses\n\nf_P: Resultant linear momenta of the beam element\nf_H: Resultant angular momenta of the beam element\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.element_residual!","page":"Library","title":"GEBT.element_residual!","text":"element_residual!(resid, x, ibeam, beam, distributed_loads, icol, irow_b,\n\tirow_b1, irow_p1, irow_b2, irow_p2)\nelement_residual!(resid, x, ibeam, beam, distributed_loads, icol, irow_b,\n\tirow_b1, irow_p1, irow_b2, irow_p2, x0, v0, ω0)\nelement_residual!(resid, x, ibeam, beam, distributed_loads, icol, irow_b,\n\tirow_b1, irow_p1, irow_b2, irow_p2, x0, v0, ω0, u0, θ0, udot0, θdot0)\nelement_residual!(resid, x, ibeam, beam, distributed_loads, icol, irow_b,\n\tirow_b1, irow_p1, irow_b2, irow_p2, x0, v0, ω0, udot_init, θdot_init,\n\tCtCabPdot_init, CtCabHdot_init, dt)\n\nCompute and add a beam element's contributions to the residual vector\n\nThere are four implementations corresponding to the following analysis types:\n\nStatic\nDynamic - Steady State\nDynamic - Initial Step (for initializing time domain simulations)\nDynamic - Time Marching\n\nSee \"GEBT: A general-purpose nonlinear analysis tool for composite beams\" by Wenbin Yu and \"Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters\" by Qi Wang and Wenbin Yu.\n\nArguments\n\nresid: System residual vector\nx: current state vector\nibeam: beam element index\nbeam: beam element\ndistributed_loads: dictionary with all distributed loads\nistep: current time step\nicol: starting index for the beam's state variables\nirow_b1: Row index of the first equation for the left side of the beam element  (a value <= 0 indicates the equations have been eliminated from the system of equations)\nirow_p1: Row index of the first equation for the point on the left side of the beam element\nirow_b2: Row index of the first equation for the right side of the beam element  (a value <= 0 indicates the equations have been eliminated from the system of equations)\nirow_p2: Row index of the first equation for the point on the right side of the beam element\n\nAdditional Arguments for Dynamic Analyses\n\nx0: Global frame origin (for the current time step)\nv0: Global frame linear velocity (for the current time step)\nω0: Global frame angular velocity (for the current time step)\n\nAdditional Arguments for Initial Step Analyses\n\nu0: initial deflection variables for each beam element\nθ0: initial rotation variables for each beam element\nudot0: initial time derivative of u for each beam element\nθdot0: initial time derivative of θ for each beam element\n\nAdditional Arguments for Time Marching Analyses\n\nudot_init: 2/dt*u + udot for each beam element from the previous time step\nθdot_init: 2/dt*θ + θdot for each beam element from the previous time step\nCtCabPdot_init: 2/dt*C'*Cab*P + C'*Cab*Pdot for each beam element from the previous time step\nCtCabHdot_init: 2/dt*C'*Cab*H + C'*Cab*Hdot for each beam element from the previous time step\ndt: time step size\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.element_jacobian_equations","page":"Library","title":"GEBT.element_jacobian_equations","text":"element_jacobian_equations(beam, ΔL, Ct, Cab, CtCab, θ, F, M, γ, κ, Ct_θ1,\n\tCt_θ2, Ct_θ3)\nelement_jacobian_equations(beam, ΔL, Cab, CtCab, θ, F, M, γ, κ, ω, P, H, V,\n\tCt_θ1, Ct_θ2, Ct_θ3)\nelement_jacobian_equations(beam, ΔL, Cab, CtCab, θ, F, γ, ω, P, V, θdot)\nelement_jacobian_equations(beam, ΔL, Cab, CtCab, θ, F, M, γ, κ, ω, P, H, V,\n\tθdot, dt, Ct_θ1, Ct_θ2, Ct_θ3)\n\nFind the jacobians of the nonlinear equations for a beam element with respect to the state variables given the distributed loads on the beam element and the beam element's properties.\n\nThere are four implementations corresponding to the following analysis types:\n\nStatic\nDynamic - Steady State\nDynamic - Initial Step (for initializing time domain simulations)\nDynamic - Time Marching\n\nSee \"GEBT: A general-purpose nonlinear analysis tool for composite beams\" by Wenbin Yu and \"Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters\" by Qi Wang and Wenbin Yu.\n\nArguments:\n\nbeam: Beam element\nΔL: Length of the beam element\nCt: Rotation tensor of the beam deformation in the \"a\" frame, transposed\nCab: Direction cosine matrix from \"a\" to \"b\" frame for the element\nCtCab: C'*Cab, precomputed for efficiency\nu: Displacement variables for the element [u1, u2, u3]\nθ: Rotation variables for the element [θ1, θ2, θ3]\nF: Force variables for the element [F1, F2, F3]\nM: Moment variables for the element [M1, M2, M3]\nγ: Engineering strains in the element [γ11, 2γ12, 2γ13]\nκ: Curvatures in the element [κ1, κ2, κ3]\nCt_θ1: Gradient of Ct w.r.t. θ[1]\nCt_θ2: Gradient of Ct w.r.t. θ[2]\nCt_θ3: Gradient of Ct w.r.t. θ[3]\nf1_θ: Gradient w.r.t. θ of integrated distributed force for left side of element\nm1_θ: Gradient w.r.t. θ of integrated distributed moment for left side of element\nf2_θ: Gradient w.r.t. θ of integrated distributed force for right side of element\nm2_θ: Gradient w.r.t. θ of integrated distributed moment for right side of element\n\nAdditional Arguments for Dynamic Analyses\n\nv: Linear velocity of element in global frame \"a\" [v1, v2, v3]\nω: Angular velocity of element in global frame \"a\" [ω1, ω2, ω3]\nP: Linear momenta for the element [P1, P2, P3]\nH: Angular momenta for the element [H1, H2, H3]\nV: Velocity of the element\nΩ: Rotational velocity of the element\n\nAdditional Arguments for Initial Step Analyses\n\nudot: user-specified time derivative of u for this beam element\nθdot: user-specified time derivative of θ for this beam element\nCtCabPdot: C'*Cab*Pdot (which is a state variable for the initial step analysis)\nCtCabHdot: C'*Cab*Hdot (which is a state variable for the initial step analysis)\n\nAdditional Arguments for Time Marching Analyses\n\nudot: -2/dt*u - udot for each beam element from the previous time step\nθdot_init: -2/dt*θ - θdot for each beam element from the previous time step\nCtCabPdot: -2/dt*C'*Cab*P - C'*Cab*Pdot for each beam element from the previous time step\nCtCabHdot: -2/dt*C'*Cab*H - C'*Cab*Hdot for each beam element from the previous time step\ndt: time step size\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.insert_element_jacobian!","page":"Library","title":"GEBT.insert_element_jacobian!","text":"insert_element_jacobian!(jacob, irow_b1, irow_p1, irow_b2, irow_p2, icol,\n\tf_u1_θ, f_u2_θ, f_u1_F, f_u2_F,\n\tf_ψ1_θ, f_ψ2_θ, f_ψ1_F, f_ψ2_F, f_ψ1_M, f_ψ2_M,\n\tf_F1_u, f_F2_u, f_F1_θ, f_F2_θ, f_F1_F, f_F2_F, f_F1_M, f_F2_M,\n\tf_M1_θ, f_M2_θ, f_M1_F, f_M2_F, f_M1_M, f_M2_M)\ninsert_element_jacobian!(jacob, irow_b1, irow_p1, irow_b2, irow_p2, icol,\n\tf_u1_θ, f_u2_θ, f_u1_F, f_u2_F, f_u1_P, f_u2_P,\n\tf_ψ1_θ, f_ψ2_θ, f_ψ1_F, f_ψ2_F, f_ψ1_M, f_ψ2_M, f_ψ1_P, f_ψ2_P, f_ψ1_H, f_ψ2_H,\n\tf_F1_u, f_F2_u, f_F1_θ, f_F2_θ, f_F1_F, f_F2_F, f_F1_M, f_F2_M,\n\tf_M1_θ, f_M2_θ, f_M1_F, f_M2_F, f_M1_M, f_M2_M,\n\tf_P_u, f_P_θ, f_P_P, f_P_H,\n\tf_H_θ, f_H_P, f_H_H)\ninsert_element_jacobian!(jacob, irow_b1, irow_p1, irow_b2, irow_p2, icol,\n\tf_u1_CtCabPdot, f_u2_CtCabPdot, f_u1_F, f_u2_F, f_u1_P, f_u2_P,\n\tf_ψ1_CtCabHdot, f_ψ2_CtCabHdot, f_ψ1_F, f_ψ2_F, f_ψ1_M, f_ψ2_M, f_ψ1_P, f_ψ2_P, f_ψ1_H, f_ψ2_H,\n\tf_F1_F, f_F2_F, f_F1_M, f_F2_M,\n\tf_M1_F, f_M2_F, f_M1_M, f_M2_M,\n\tf_P_P, f_P_H,\n\tf_H_P, f_H_H)\n\nInsert the the beam element jacobian entries into the jacobian matrix\n\nThere are three implementations corresponding to the following analysis types:\n\nStatic\nDynamic - Steady State or Time Marching\nDynamic - Initial Step (for initializing time domain simulations)\n\nArguments\n\njacob: System jacobian matrix\nicol_p1: Row/column index of the first unknown for the left endpoint (a value <= 0 indicates the unknowns have been eliminated from the system of equations)\nirow_b1: Row index of the first equation for the left side of the beam\nirow_p1: Row index of the first equation for the point on the left side of the beam\nicol_p2: Row/column index of the first unknown for the right endpoint\n\n(a value <= 0 indicates the unknowns have been eliminated from the system of equations)\n\nirow_b2: Row index of the first equation for the right side of the beam\nirow_p2: Row index of the first equation for the point on the right side of the beam\nicol: Row/Column index corresponding to the first beam state variable\n\nAll other arguments use the following naming convention:\n\nf_y_x: Jacobian of element equation \"y\" with respect to state variable \"x\"\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.element_jacobian!","page":"Library","title":"GEBT.element_jacobian!","text":"element_jacobian!(jacob, x, ibeam, beam, distributed_loads, icol, irow_b,\n\tirow_b1, irow_p1, irow_b2, irow_p2)\nelement_jacobian!(jacob, x, ibeam, beam, distributed_loads, icol, irow_b,\n\tirow_b1, irow_p1, irow_b2, irow_p2, x0, v0, ω0)\nelement_jacobian!(jacob, x, ibeam, beam, distributed_loads, icol, irow_b,\n\tirow_b1, irow_p1, irow_b2, irow_p2, x0, v0, ω0, u0, θ0, udot0, θdot0)\nelement_jacobian!(jacob, x, ibeam, beam, distributed_loads, icol, irow_b,\n\tirow_b1, irow_p1, irow_b2, irow_p2, x0, v0, ω0, udot_init, θdot_init,\n\tCtCabPdot_init, CtCabHdot_init, dt)\n\nAdds a beam element's contributions to the jacobian matrix\n\nThere are four implementations corresponding to the following analysis types:\n\nStatic\nDynamic - Steady State\nDynamic - Initial Step (for initializing time domain simulations)\nDynamic - Time Marching\n\nSee \"GEBT: A general-purpose nonlinear analysis tool for composite beams\" by Wenbin Yu and \"Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters\" by Qi Wang and Wenbin Yu.\n\nArguments\n\njacob: System jacobian matrix\nx: current state vector\nibeam: beam element index\nbeam: beam element\ndistributed_loads: dictionary with all distributed loads\nistep: current time step\nicol: starting index for the beam's state variables\nirow_b1: Row index of the first equation for the left side of the beam element  (a value <= 0 indicates the equations have been eliminated from the system of equations)\nirow_p1: Row index of the first equation for the point on the left side of the beam element\nirow_b2: Row index of the first equation for the right side of the beam element  (a value <= 0 indicates the equations have been eliminated from the system of equations)\nirow_p2: Row index of the first equation for the point on the right side of the beam element\n\nAdditional Arguments for Dynamic Analyses\n\nx0: Global frame origin (for the current time step)\nv0: Global frame linear velocity (for the current time step)\nω0: Global frame angular velocity (for the current time step)\n\nAdditional Arguments for Initial Step Analyses\n\nu0: initial deflection variables for each beam element\nθ0: initial rotation variables for each beam element\nudot0: initial time derivative of u for each beam element\nθdot0: initial time derivative of θ for each beam element\n\nAdditional Arguments for Time Marching Analyses\n\nudot_init: 2/dt*u + udot for each beam element from the previous time step\nθdot_init: 2/dt*θ + θdot for each beam element from the previous time step\nCtCabPdot_init: 2/dt*C'*Cab*P + C'*Cab*Pdot for each beam element from the previous time step\nCtCabHdot_init: 2/dt*C'*Cab*H + C'*Cab*Hdot for each beam element from the previous time step\ndt: time step size\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.element_mass_matrix_properties","page":"Library","title":"GEBT.element_mass_matrix_properties","text":"element_mass_matrix_properties(x, icol, beam)\n\nExtract/Compute the properties needed for mass matrix construction: ΔL, Ct, Cab, CtCab, θ, P, H, Ctdot_cdot1, Ctdot_cdot2, and Ctdot_cdot3\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.element_mass_matrix_equations","page":"Library","title":"GEBT.element_mass_matrix_equations","text":"element_mass_matrix_equations(ΔL, Ct, Cab, CtCab, θ, P, H)\n\nCalculates the jacobians of the nonlinear equations for a beam element with respect to the time derivatives of the state variables.\n\nSee \"GEBT: A general-purpose nonlinear analysis tool for composite beams\" by Wenbin Yu and \"Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters\" by Qi Wang and Wenbin Yu.\n\nArguments:\n\nΔL: Length of the beam element\nCt: Rotation tensor of the beam deformation in the \"a\" frame, transposed\nCab: Direction cosine matrix from \"a\" to \"b\" frame for the element\nθ: Rotation variables for the element [θ1, θ2, θ3]\nP: Linear momenta for the element [P1, P2, P3]\nH: Angular momenta for the element [H1, H2, H3]\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.insert_element_mass_matrix!","page":"Library","title":"GEBT.insert_element_mass_matrix!","text":"insert_element_mass_matrix!(jacob, irow_b1, irow_p1, irow_b2, irow_p2, icol,\n\tf_u1_θdot, f_u2_θdot, f_u1_Pdot, f_u2_Pdot, f_ψ1_θdot, f_ψ2_θdot,\n\tf_ψ1_Hdot, f_ψ2_Hdot, f_P_udot, f_H_θdot)\n\nInsert the beam element's contributions into the \"mass matrix\": the jacobian of the residual equations with respect to the time derivatives of the state variables\n\nArguments\n\njacob: System jacobian matrix (mass matrix)\nirow_b1: Row index of the first equation for the left side of the beam\nirow_p1: Row index of the first equation for the point on the left side of the beam\nirow_b2: Row index of the first equation for the right side of the beam\nirow_p2: Row index of the first equation for the point on the right side of the beam\nicol: Row/Column index corresponding to the first beam state variable\n\nAll other arguments use the following naming convention:\n\nf_y_x: Jacobian of element equation \"y\" with respect to state variable \"x\"\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.element_mass_matrix!","page":"Library","title":"GEBT.element_mass_matrix!","text":"element_mass_matrix!(jacob, x, beam, icol, irow_b, irow_b1, irow_p1, irow_b2, irow_p2)\n\nAdd the beam element's contributions to the \"mass matrix\": the jacobian of the residual equations with respect to the time derivatives of the state variables\n\nSee \"GEBT: A general-purpose nonlinear analysis tool for composite beams\" by Wenbin Yu and \"Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters\" by Qi Wang and Wenbin Yu.\n\nArguments\n\njacob: System jacobian matrix\nx: current state vector\nbeam: beam element\nicol: starting index for the beam's state variables\nirow_b1: Row index of the first equation for the left side of the beam element  (a value <= 0 indicates the equations have been eliminated from the system of equations)\nirow_p1: Row index of the first equation for the point on the left side of the beam element\nirow_b2: Row index of the first equation for the right side of the beam element  (a value <= 0 indicates the equations have been eliminated from the system of equations)\nirow_p2: Row index of the first equation for the point on the right side of the beam element\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.ElementState","page":"Library","title":"GEBT.ElementState","text":"ElementState\n\nHolds the state variables for an element\n\nFields:\n\nu: Displacement variables for the element\ntheta: Wiener-Milenkovic rotation variables for the element\nF: Resultant forces for the element\nM: Resultant moments for the element\nP: Linear momenta of the element\nH: Angular momenta of the element\n\n\n\n\n\n","category":"type"},{"location":"library/#Loads","page":"Library","title":"Loads","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"GEBT.PrescribedConditions\nGEBT.DistributedLoads","category":"page"},{"location":"library/#GEBT.PrescribedConditions","page":"Library","title":"GEBT.PrescribedConditions","text":"PrescribedConditions{T}\n\nDescribes the forces, moments, displacements, and/or rotations prescribed at a point for each time step\n\n\n\n\n\n","category":"type"},{"location":"library/#GEBT.DistributedLoads","page":"Library","title":"GEBT.DistributedLoads","text":"DistributedLoads{T}\n\nContains the integrated distributed forces and moments for each beam element for each time step.\n\nFields\n\nf1: Integrated non-follower distributed force for the beam element's left endpoint for each time step\nf2: Integrated non-follower distributed force for the beam element's right endpoint for each time step\nm1: Integrated non-follower distributed moment for the beam element's left endpoint for each time step\nm2: Integrated non-follower distributed moment for the beam element's right endpoint for each time step\nf1_follower: Integrated follower distributed force for the beam element's left endpoint for each time step\nf2_follower: Integrated follower distributed force for the beam element's right endpoint for each time step\nm1_follower: Integrated follower distributed moment for the beam element's left endpoint for each time step\nm2_follower: Integrated follower distributed moment for the beam element's right endpoint for each time step\n\n\n\n\n\n","category":"type"},{"location":"library/#System","page":"Library","title":"System","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"GEBT.Assembly\nGEBT.System\nGEBT.point_connections\nGEBT.system_indices\nGEBT.system_residual!\nGEBT.system_jacobian!\nGEBT.system_mass_matrix!","category":"page"},{"location":"library/#GEBT.Assembly","page":"Library","title":"GEBT.Assembly","text":"Assembly{TF, TP<:AbstractVector{<:AbstractVector{TF}}, TC<:AbstractVector{<:Integer}, TE<:AbstractVector{Element{TF}}}\n\nComposite type that defines an assembly of connected nonlinear beam elements for analysis.\n\nFields\n\npoints: Array of all beam element endpoints\nstart: Array containing point index where each beam element starts\nstop: Array containing point index where each beam element stops\nelement: Array of Elements\n\n\n\n\n\n","category":"type"},{"location":"library/#GEBT.System","page":"Library","title":"GEBT.System","text":"System{TF, TV<:AbstractVector{TF}, TM<:AbstractMatrix{TF}, TTF<:AbstractVector{TF}}\n\nContains the system state, residual vector, and jacobian matrices as well as pointers to be able to access their contents.  Also contains additional storage needed for time domain simulations.\n\nFields:\n\nstatic: Flag indicating whether system matrices are only valid for static analyses\nx: State vector\nr: Residual vector\nK: System jacobian matrix with respect to the state variables\nM: System jacobian matrix with respect to the time derivative of the state variables\nirow_pt: Row index of first equilibrium equation for each point\nirow_beam: Row index of first equation for just this beam element\nirow_beam1: Row index of first equation for the left side of each beam\nirow_beam2: Row index of first equation for the right side of each beam\nicol_pt: Row/Column index of first state variable for each point\nicol_beam: Row/Column index of first state variable for each beam element\ncurrent_step: Current time step\nudot_init: 2/dt*u + udot for each beam element from the previous time step\nθdot_init: 2/dt*θ + θdot for each beam element from the previous time step\nCtCabPdot_init: 2/dt*C'*Cab*P + C'*Cab*Pdot for each beam element from the previous time step\nCtCabHdot_init: 2/dt*C'*Cab*H + C'*Cab*Hdot for each beam element from the previous time step\n\n\n\n\n\n","category":"type"},{"location":"library/#GEBT.point_connections","page":"Library","title":"GEBT.point_connections","text":"point_connections(assembly)\n\nCount the number of beams connected to each point\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.system_indices","page":"Library","title":"GEBT.system_indices","text":"system_indices(assembly, points, n_connections, static)\n\nSolve for the row indices of the first equilibrium or compatability equations for each point and side of each beam element.  Also solve for the row/column index of each point and beam state variable.\n\nIf only two beams meet at a point, the 6 unknowns associated with that point as well as the 6 compatability equations are eliminated from the system, except if specified in the array points.  Points for which unknowns have been eliminated are assigned a column index of -1.  Beams for which the compatability equations have been eliminated are also assigned an index of -1\n\nArguments:\n\nassembly: Assembly of rigidly connected nonlinear beam elements\npoints: Point indices which should be preserved in the system matrices\nn_connections: Number of connections to each point\nstatic: flag indicating whether analysis is static\n\nReturn Arguments:\n\nn: total number of equations/unknowns in the system\nirow_pt: Row index of first equilibrium equation for each point\nirow_beam: Row index of first equation for just this beam element\nirow_beam1: Row index of first equation for the left side of each beam\nirow_beam2: Row index of first equation for the right side of each beam\nicol_pt: Column index of first state variable for each point\nicol_beam: Column index of first state variable for each beam element\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.system_residual!","page":"Library","title":"GEBT.system_residual!","text":"system_residual!(resid, x, assembly, prescribed_conditions, distributed_loads,\n\tistep, irow_pt, irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam)\nsystem_residual!(resid, x, assembly, prescribed_conditions, distributed_loads,\n\tistep, irow_pt, irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam, x0, v0, ω0)\nsystem_residual!(resid, x, assembly, prescribed_conditions, distributed_loads,\n\tistep, irow_pt, irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam, x0, v0, ω0,\n\tu, θ, udot, θdot)\nsystem_residual!(resid, x, assembly, prescribed_conditions, distributed_loads,\n\tistep, irow_pt, irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam, x0, v0, ω0,\n\tudot, θdot_init, CtCabPdot, CtCabHdot, dt)\n\nPopulate the residual vector resid with the results of the residual equations for the system.\n\nThere are four implementations corresponding to the following analysis types:\n\nStatic\nDynamic - Steady State\nDynamic - Initial Step (for initializing time domain simulations)\nDynamic - Time Marching\n\nSee \"GEBT: A general-purpose nonlinear analysis tool for composite beams\" by  Wenbin Yu and \"Geometrically nonlinear analysis of composite beams using  Wiener-Milenković parameters\" by Qi Wang and Wenbin Yu.\n\nArguments\n\nresid: System residual vector\nx: Current state variables of the system\nassembly: Assembly of rigidly connected nonlinear beam elements\nprescribed_conditions: Dictionary of prescribed conditions at all time steps\ndistributed_loads: Dictionary of distributed loads at all time steps\nistep: Current time step\nirow_pt: Row index of first equilibrium equation for each point\nirow_beam: Row index of first equation for just this beam element\nirow_beam1: Row index of first equation for the left side of each beam\nirow_beam2: Row index of first equation for the right side of each beam\nicol_pt: Column index of first state variable for each point\nicol_beam: Column index of first state variable for each beam element\n\nAdditional Arguments for Dynamic Analyses\n\nx0: Global frame origin (for the current time step)\nv0: Global frame linear velocity (for the current time step)\nω0: Global frame angular velocity (for the current time step)\n\nAdditional Arguments for Initial Step Analyses\n\nu: deflection variables for each beam element\nθ: rotation variables for each beam element\nudot: time derivative of u for each beam element\nθdot: time derivative of θ for each beam element\n\nAdditional Arguments for Time Marching Analyses\n\nudot: -2/dt*u - udot for each beam element from the previous time step\nθdot_init: -2/dt*θ - θdot for each beam element from the previous time step\nCtCabPdot: -2/dt*C'*Cab*P - C'*Cab*Pdot for each beam element from the previous time step\nCtCabHdot: -2/dt*C'*Cab*H - C'*Cab*Hdot for each beam element from the previous time step\ndt: time step size\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.system_jacobian!","page":"Library","title":"GEBT.system_jacobian!","text":"system_jacobian!(jacob, x, assembly, prescribed_conditions, distributed_loads,\n\tistep, irow_pt, irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam)\nsystem_jacobian!(jacob, x, assembly, prescribed_conditions, distributed_loads,\n\tistep, irow_pt, irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam,\n\tx0, v0, ω0)\nsystem_jacobian!(jacob, x, assembly, prescribed_conditions, distributed_loads,\n\tistep, irow_pt, irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam,\n\tx0, v0, ω0, u, θ, udot, θdot)\nsystem_jacobian!(jacob, x, assembly, prescribed_conditions, distributed_loads,\n\tistep, irow_pt, irow_beam, irow_beam1, irow_beam2, icol_pt, icol_beam,\n\tx0, v0, ω0, udot_init, θdot_init, CtCabPdot_init, CtCabHdot_init, dt)\n\nPopulate the jacobian matrix jacob with the jacobian of the residual vector with respect to the state variables.\n\nThere are four implementations corresponding to the following analysis types:\n\nStatic\nDynamic - Steady State\nDynamic - Initial Step (for initializing time domain simulations)\nDynamic - Time Marching\n\nSee \"GEBT: A general-purpose nonlinear analysis tool for composite beams\" by  Wenbin Yu and \"Geometrically nonlinear analysis of composite beams using  Wiener-Milenković parameters\" by Qi Wang and Wenbin Yu.\n\nArguments\n\njacob: Jacobian matrix\nx: Vector containing current state variables of the system\nassembly: Assembly of rigidly connected nonlinear beam elements\nprescribed_conditions: Dictionary of prescribed conditions at all time steps\ndistributed_loads: Dictionary of distributed loads at all time steps\nistep: Current time step\nirow_pt: Row index of first equilibrium equation for each point\nirow_beam: Row index of first equation for just this beam element\nirow_beam1: Row index of first equation for the left side of each beam\nirow_beam2: Row index of first equation for the right side of each beam\nicol_pt: Column index of first state variable for each point\nicol_beam: Column index of first state variable for each beam element\n\nAdditional Arguments for Dynamic Analyses\n\nx0: Global frame origin (for the current time step)\nv0: Global frame linear velocity (for the current time step)\nω0: Global frame angular velocity (for the current time step)\n\nAdditional Arguments for Initial Step Analyses\n\nu: deflection variables for each beam element\nθ: rotation variables for each beam element\nudot: time derivative of u for each beam element\nθdot: time derivative of θ for each beam element\n\nAdditional Arguments for Time Marching Analyses\n\nudot: -2/dt*u - udot for each beam element from the previous time step\nθdot_init: -2/dt*θ - θdot for each beam element from the previous time step\nCtCabPdot: -2/dt*C'*Cab*P - C'*Cab*Pdot for each beam element from the previous time step\nCtCabHdot: -2/dt*C'*Cab*H - C'*Cab*Hdot for each beam element from the previous time step\ndt: time step size\n\n\n\n\n\n","category":"function"},{"location":"library/#GEBT.system_mass_matrix!","page":"Library","title":"GEBT.system_mass_matrix!","text":"system_mass_matrix!(jacob, x, assembly, irow_pt, irow_beam, irow_beam1,\n\tirow_beam2, icol_pt, icol_beam)\n\nPopulate the system \"mass matrix\", the jacobian of the residual vector with respect to the time derivatives of the state variables.\n\nSee \"GEBT: A general-purpose nonlinear analysis tool for composite beams\" by Wenbin Yu and \"Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters\" by Qi Wang and Wenbin Yu.\n\nArguments\n\njacob: Jacobian matrix\nx: Vector containing current state variables of the system\nassembly: Assembly of rigidly connected nonlinear beam elements\nirow_pt: Row index of first equilibrium equation for each point\nirow_beam: Row index of first equation for just this beam element\nirow_beam1: Row index of first equation for the left side of each beam\nirow_beam2: Row index of first equation for the right side of each beam\nicol_pt: Column index of first state variable for each point\nicol_beam: Column index of first state variable for each beam element\n\n\n\n\n\n","category":"function"},{"location":"library/#Index","page":"Library","title":"Index","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"These examples show how to use the various analysis capabilities of GEBT.jl.  Some of the examples also provide a verification/validation for the implementation of geometrically exact beam theory in GEBT.jl.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Pages = [\"examples.md\"]\nDepth = 3","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# this is placed here to pre-install matplotlib so the documentation doesn't get cluttered with the installation print statements.\nusing Plots\npyplot()","category":"page"},{"location":"examples/#Linear-Analysis-of-a-Cantilever-Partially-Under-a-Uniform-Distributed-Load","page":"Examples","title":"Linear Analysis of a Cantilever Partially Under a Uniform Distributed Load","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example shows how to predict the behavior of a cantilever beam which is partially subjected to a uniform distributed load.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing GEBT, LinearAlgebra\n\nnelem = 12\n\n# create points\nn1 = n3 = div(nelem, 3)\nn2 = nelem - n1 - n3\nx1 = range(0, 0.3, length=n1+1)\nx2 = range(0.3, 0.7, length=n2+1)\nx3 = range(0.7, 1.0, length=n3+1)\nx = vcat(x1, x2[2:end], x3[2:end])\ny = zero(x)\nz = zero(x)\npoints = [[x[i],y[i],z[i]] for i = 1:length(x)]\n\n# index of endpoints for each beam element\nstart = 1:nelem\nstop = 2:nelem+1\n\n# create compliance matrix for each beam element\ncompliance = fill(Diagonal([2.93944738387698E-10, 0, 0, 4.69246721094557E-08, 6.79584e-8, 1.37068861370898E-09]), nelem)\n\n# create assembly\nassembly = Assembly(points, start, stop, compliance=compliance)\n\n# set prescribed conditions (fixed right endpoint)\nprescribed_conditions = Dict(\n    nelem+1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0)\n)\n\n# create distributed load\ndistributed_loads = Dict()\nfor ielem in n1+1:n1+n2\n    distributed_loads[ielem] = DistributedLoads(assembly, ielem; fz = (s) -> 1000)\nend\n\nsystem, converged = static_analysis(assembly, prescribed_conditions=prescribed_conditions,\n    distributed_loads=distributed_loads, linear=true)\n\nstate = AssemblyState(system, assembly, prescribed_conditions=prescribed_conditions)\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can construct the analytical solution for this problem by integrating from the fixed end of the cantilever.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# construct analytical solution\ndx = 1e-6\nEI = 1/6.79584e-8\nx_a = 0.0:dx:1.0\nq_a(x) = 0.3 <= x <= 0.7 ? -1000 : 0 # define distributed load\nV_a = cumsum(-q_a.(x_a) .* dx) # integrate to get shear\nM_a = cumsum(V_a .* dx) # integrate to get moment\nslope_a = cumsum(M_a./EI .* dx) # integrate to get slope\nslope_a .-= slope_a[end] # apply boundary condition\ndeflection_a = cumsum(slope_a .* dx) # integrate to get deflection\ndeflection_a .-= deflection_a[end] # apply boundary condition\n\n# get elastic twist angle\ntheta_a = -atan.(slope_a)\n\n# adjust coordinate system of the analytical solution to match the computational solution\nM_a = -M_a\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Plotting the results reveals that the analytical and computational solutions are identical.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Plots\npyplot()\n\n# deflection plot\nplot(\n    xlim = (0.0, 1.0),\n    xticks = 0.0:0.2:1.0,\n    xlabel = \"x (m)\",\n    yticks = 0.0:5e-7:3e-6,\n    ylabel = \"Deflection (m)\",\n    grid = false,\n    overwrite_figure=false\n    )\n\nx = [assembly.points[ipoint][1] + state.points[ipoint].u[1] for ipoint = 1:length(assembly.points)]\ndeflection = [state.points[ipoint].u[3] for ipoint = 1:length(assembly.points)]\nplot!(x_a, deflection_a, label=\"Analytical\")\nscatter!(x, deflection, label=\"GEBT\")\n\nsavefig(\"linear-cantilever-pudl-1.svg\") #hide\n\n# elastic twist plot (euler angle)\nplot(\n    xlim = (0.0, 1.0),\n    xticks = 0.0:0.2:1.0,\n    xlabel = \"x (m)\",\n    yticks = 0.0:5e-7:3.5e-6,\n    ylabel = \"Rotation Parameter \\$\\\\theta_y\\$ (Euler Angle)\",\n    grid = false,\n    overwrite_figure=false\n    )\n\nx = [assembly.points[ipoint][1] + state.points[ipoint].u[1] for ipoint = 1:length(assembly.points)]\ntheta = [4*atan.(state.points[ipoint].theta[2]/4) for ipoint = 1:length(assembly.points)]\nplot!(x_a, theta_a, label=\"Analytical\")\nscatter!(x, theta, label=\"GEBT\")\n\nsavefig(\"linear-cantilever-pudl-2.svg\") #hide\n\n# bending moment plot\nplot(\n    xlim = (0.0, 1.0),\n    xticks = 0.0:0.2:1.0,\n    xlabel = \"x (m)\",\n    yticks = 0.0:-50:-200,\n    ylabel = \"Bending Moment (\\$Nm\\$)\",\n    grid = false,\n    overwrite_figure=false\n    )\n\nx = [assembly.elements[ielem].x[1] + state.elements[ielem].u[1] for ielem = 1:length(assembly.elements)]\nM = [state.elements[ielem].M[2] for ielem = 1:length(assembly.elements)]\nplot!(x_a, M_a, label=\"Analytical\")\nscatter!(x, M, label=\"GEBT\")\n\nsavefig(\"linear-cantilever-pudl-3.svg\") #hide\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Note that we could have easily performed a nonlinear analysis for this problem by setting linear=false.","category":"page"},{"location":"examples/#Linear-Analysis-of-a-Beam-Under-a-Linear-Distributed-Load","page":"Examples","title":"Linear Analysis of a Beam Under a Linear Distributed Load","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example shows how to predict the behavior of a beam which is clamped at one end and simply supported at the other end when subjected to a linear distributed load.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing GEBT, LinearAlgebra\n\nnelem = 16\n\n# create points\nx = range(0, 1, length=nelem+1)\ny = zero(x)\nz = zero(x)\npoints = [[x[i],y[i],z[i]] for i = 1:length(x)]\n\n# index of endpoints for each beam element\nstart = 1:nelem\nstop = 2:nelem+1\n\n# create compliance matrix for each beam element\ncompliance = fill(Diagonal([2.93944738387698E-10, 0, 0, 4.69246721094557E-08, 6.79584e-8, 1.37068861370898E-09]), nelem)\n\n# create assembly\nassembly = Assembly(points, start, stop, compliance=compliance)\n\n# set prescribed conditions\nprescribed_conditions = Dict(\n    # simply supported left endpoint\n    1 => PrescribedConditions(uz=0),\n    # clamped right endpoint\n    nelem+1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0)\n)\n\n# create distributed load\ndistributed_loads = Dict()\nfor i = 1:nelem\n    distributed_loads[i] = DistributedLoads(assembly, i; s1=x[i],\n        s2=x[i+1], fz = (s) -> 1000*s)\nend\n\nsystem, converged = static_analysis(assembly, prescribed_conditions=prescribed_conditions,\n    distributed_loads=distributed_loads, linear=true)\n\nstate = AssemblyState(system, assembly, prescribed_conditions=prescribed_conditions)\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"An analytical solution to this over-determined problem can be found using the method of superposition using the analytical solutions to a cantilever with a linearly distributed load and a cantilever with an end load.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# construct analytical solution\nEI = 1/6.79584e-8\nx_a = range(0.0, 1.0, length=1000)\nw_a = @. 1000*(1-x_a)^2/(120*EI)*(4 - 8*(1-x_a) + 5*(1-x_a)^2 - (1-x_a)^3)\nslope_a = @. -1000*(1-x_a)/(120*EI)*(8 - 24*(1-x_a) + 20*(1-x_a)^2 - 5*(1-x_a)^3)\nM_a = @. 1000/120*(8 - 48*(1-x_a) + 60*(1-x_a)^2 - 20*(1-x_a)^3)\n\ntheta_a = -atan.(slope_a)\n\n# adjust coordinate system of analytical solution\nM_a = -M_a\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Plotting the results reveals that the analytical and computational solutions are identical.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Plots\npyplot()\n\n# set up the plot\nplot(\n    xlim = (0.0, 1.0),\n    xticks = 0.0:0.2:1.0,\n    xlabel = \"x (m)\",\n    ylim = (0, 1.7e-7),\n    yticks = 0.0:5e-8:1.5e-7,\n    ylabel = \"Deflection (m)\",\n    grid = false,\n    overwrite_figure=false\n    )\n\nx = [assembly.points[ipoint][1] + state.points[ipoint].u[1] for ipoint = 1:length(assembly.points)]\ndeflection = [state.points[ipoint].u[3] for ipoint = 1:length(assembly.points)]\nplot!(x_a, w_a, label=\"Analytical\")\nscatter!(x, deflection, label=\"GEBT\")\n\nsavefig(\"linear-overdetermined-ldl-1.svg\") #hide\n\nplot(\n    xlim = (0.0, 1.0),\n    xticks = 0.0:0.2:1.0,\n    xlabel = \"x (m)\",\n    ylim = (-6e-7,Inf),\n    yticks = -6e-7:2e-7:4e-7,\n    ylabel = \"Rotation Parameter \\$\\\\theta_y\\$ (Euler Angle)\",\n    grid = false,\n    overwrite_figure=false\n    )\n\nx = [assembly.points[ipoint][1] + state.points[ipoint].u[1] for ipoint = 1:length(assembly.points)]\ntheta = [4*atan.(state.points[ipoint].theta[2]/4) for ipoint = 1:length(assembly.points)]\nplot!(x_a, theta_a, label=\"Analytical\")\nscatter!(x, theta, label=\"GEBT\")\n\nsavefig(\"linear-overdetermined-ldl-2.svg\") #hide\n\nplot(\n    xlim = (0.0, 1.0),\n    xticks = 0.0:0.2:1.0,\n    xlabel = \"x (m)\",\n    yticks = -60:20:20,\n    ylabel = \"Bending Moment (\\$Nm\\$)\",\n    grid = false,\n    overwrite_figure=false\n    )\n\nx = [assembly.elements[ielem].x[1] + state.elements[ielem].u[1] for ielem = 1:length(assembly.elements)]\nM = [state.elements[ielem].M[2] for ielem = 1:length(assembly.elements)]\nplot!(x_a, M_a, label=\"Analytical\")\nscatter!(x, M, label=\"GEBT\")\n\nsavefig(\"linear-overdetermined-ldl-3.svg\") #hide\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Note that we could have easily performed a nonlinear analysis for this problem by setting linear=false.","category":"page"},{"location":"examples/#Nonlinear-Analysis-of-a-Cantilever-Subjected-to-a-Constant-Tip-Load","page":"Examples","title":"Nonlinear Analysis of a Cantilever Subjected to a Constant Tip Load","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example shows how to predict the behavior of a cantilever beam that is subjected to a constant tip load.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing GEBT, LinearAlgebra\n\nL = 1\nEI = 1e6\n\n# shear force (applied at end)\n# note that solutions for λ > 1.8 do not converge\nλ = 0:0.5:16\np = EI/L^2\nP = λ*p\n\n# create points\nnelem = 16\nx = range(0, L, length=nelem+1)\ny = zero(x)\nz = zero(x)\npoints = [[x[i],y[i],z[i]] for i = 1:length(x)]\n\n# index of endpoints of each beam element\nstart = 1:nelem\nstop = 2:nelem+1\n\n# compliance matrix for each beam element\ncompliance = fill(Diagonal([0, 0, 0, 0, 1/EI, 0]), nelem)\n\n# create assembly of interconnected nonlinear beams\nassembly = Assembly(points, start, stop, compliance=compliance)\n\n# pre-initialize system storage\nstatic = true\nkeep_points = [1, nelem+1] # points that we request are included in the system of equations\nsystem = System(assembly, keep_points, static)\n\n# run an analysis for each prescribed tip load\n\nstates = Vector{AssemblyState{Float64}}(undef, length(P))\n\nfor i = 1:length(P)\n\n    # create dictionary of prescribed conditions\n    prescribed_conditions = Dict(\n        # fixed left side\n        1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0),\n        # shear force on right tip\n        nelem+1 => PrescribedConditions(Fz = P[i])\n    )\n\n    static_analysis!(system, assembly, prescribed_conditions=prescribed_conditions)\n\n    states[i] = AssemblyState(system, assembly, prescribed_conditions=prescribed_conditions)\n\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The analytical solution to this problem has been presented by several authors.  Here we follow the solution by H. J. Barten in \"On the Deflection of a Cantilever Beam\", after incorporating the corrections they submitted for finding the tip angle.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"import Elliptic\n\nδ = range(pi/4, pi/2, length=10^5)[2:end-1]\n\nk = @. cos(pi/4)/sin(δ)\nλ_a = @. (Elliptic.F(pi/2, k^2) - Elliptic.F(δ,  k^2))^2\n\nθ_a = @. 2*(pi/4 - acos(k))\n\nξ_a = @. sqrt(2*sin(θ_a)/λ_a) .- 1\n\nη_a = @. 1-2/sqrt(λ_a)*(Elliptic.E(pi/2, k^2) - Elliptic.E(δ, k^2))\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Plotting the results reveals that the analytical and computational solutions are identical.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Plots\npyplot()\n\nu = [states[i].points[end].u[1] for i = 1:length(P)]\nθ = [states[i].points[end].theta[2] for i = 1:length(P)]\nw = [states[i].points[end].u[3] for i = 1:length(P)]\n\n\n# set up the plot\nplot(\n    xlim = (0, 16),\n    xticks = 0:1:16,\n    xlabel = \"Nondimensional Force \\$\\\\left(\\\\frac{PL^2}{EI}\\\\right)\\$\",\n    ylim = (0, 1.2),\n    yticks = 0.0:0.2:1.2,\n    ylabel = \"Nondimensional Tip Displacements\",\n    grid = false,\n    overwrite_figure=false\n    )\n\nplot!([Inf], [Inf], color=:black, label=\"Analytical\")\nscatter!([Inf], [Inf], color=:black, label=\"GEBT\")\nplot!([Inf], [Inf], color=1, label=\"Vertical \\$\\\\left(w/L\\\\right)\\$\")\nplot!([Inf], [Inf], color=2, label=\"Horizontal \\$\\\\left(-u/L\\\\right)\\$\")\nplot!([Inf], [Inf], color=3, label=\"\\$ \\\\theta/(\\\\pi/2) \\$\")\n\nplot!(λ_a, η_a, color=1, label=\"\")\nscatter!(λ, w/L, color=1, label=\"\")\n\nplot!(λ_a, -ξ_a, color=2, label=\"\")\nscatter!(λ, -u/L, color=2, label=\"\")\n\nplot!(λ_a, θ_a*2/pi, color=3, label=\"\")\nscatter!(λ, -4*atan.(θ/4)*2/pi, color=3, label=\"\")\n\nsavefig(\"cantilever-tipforce.svg\"); nothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Nonlinear-Analysis-of-a-Cantilever-Subjected-to-a-Constant-Moment","page":"Examples","title":"Nonlinear Analysis of a Cantilever Subjected to a Constant Moment","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example shows how to predict the behavior of a cantilever beam that is subjected to a constant tip moment.  This is a common benchmark problem for the geometrically nonlinear analysis of beams.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing GEBT, LinearAlgebra\n\nL = 12 # inches\nh = w = 1 # inches\nE = 30e6 # lb/in^4 Young's Modulus\n\nA = h*w\nIyy = w*h^3/12\nIzz = w^3*h/12\n\n# bending moment (applied at end)\n# note that solutions for λ > 1.8 do not converge\nλ = [0.0, 0.4, 0.8, 1.2, 1.6, 1.8]\nm = pi*E*Iyy/L\nM = λ*m\n\n# create points\nnelem = 16\nx = range(0, L, length=nelem+1)\ny = zero(x)\nz = zero(x)\npoints = [[x[i],y[i],z[i]] for i = 1:length(x)]\n\n# index of endpoints of each beam element\nstart = 1:nelem\nstop = 2:nelem+1\n\n# compliance matrix for each beam element\ncompliance = fill(Diagonal([1/(E*A), 0, 0, 0, 1/(E*Iyy), 1/(E*Izz)]), nelem)\n\n# create assembly of interconnected nonlinear beams\nassembly = Assembly(points, start, stop, compliance=compliance)\n\n# pre-initialize system storage\nstatic = true\nkeep_points = [1, nelem+1] # points that we request are included in the system of equations\nsystem = System(assembly, keep_points, static)\n\n# run an analysis for each prescribed bending moment\n\nstates = Vector{AssemblyState{Float64}}(undef, length(M))\n\nfor i = 1:length(M)\n\n    # create dictionary of prescribed conditions\n    prescribed_conditions = Dict(\n        # fixed left side\n        1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0),\n        # moment on right side\n        nelem+1 => PrescribedConditions(Mz = M[i])\n    )\n\n    static_analysis!(system, assembly, prescribed_conditions=prescribed_conditions)\n\n    states[i] = AssemblyState(system, assembly, prescribed_conditions=prescribed_conditions)\n\nend\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This problem has a simple analytical solution, which we obtained from \"Study of the Geometric Stiffening Effect: Comparison of Different Formulations\" by Juana M. Mayo, Daniel Garcia-Vallejo, and Jaime Dominguez.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\n# analytical solution (ρ = E*I/M)\nanalytical(x, ρ) = ifelse(ρ == Inf, zeros(3), [ρ*sin(x/ρ)-x, ρ*(1-cos(x/ρ)), 0])\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Plotting the results reveals that the analytical and computational results are identical.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Plots\npyplot()\n\n# set up the plot\nplot(\n    xlim = (-0.25, 1.1),\n    xticks = -0.25:0.25:1.0,\n    xlabel = \"x/L\",\n    ylim = (-0.05, 0.8),\n    yticks = 0.0:0.2:0.8,\n    ylabel = \"y/L\",\n    aspect_ratio = 1.0,\n    grid = false,\n    overwrite_figure=false\n    )\n\n# create dummy legend entries for GEBT and Analytical\nscatter!([NaN, NaN], [NaN, NaN], color=:black, label=\"GEBT\")\nplot!([NaN, NaN], [NaN, NaN], color=:black, label=\"Analytical\")\n\n# plot the data\nfor i = 1:length(M)\n    # GEBT\n    x = [assembly.points[ipoint][1] + states[i].points[ipoint].u[1] for ipoint = 1:length(assembly.points)]\n    y = [assembly.points[ipoint][2] + states[i].points[ipoint].u[2] for ipoint = 1:length(assembly.points)]\n    scatter!(x/L, y/L, label=\"\", color = i)\n\n    # Analytical\n    x0 = range(0, L, length=100)\n    deflection = analytical.(x0, E*Iyy/M[i])\n    x = (x0 + getindex.(deflection, 1))\n    y = getindex.(deflection, 2)\n    plot!(x/L, y/L, label=\"λ=$(λ[i])\", color=i)\nend\n\nsavefig(\"cantilever-tipmoment.svg\"); nothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Nonlinear-Analysis-of-the-Bending-of-a-Curved-Beam-in-3D-Space","page":"Examples","title":"Nonlinear Analysis of the Bending of a Curved Beam in 3D Space","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example is also a common benchmark problem for the geometrically exact bending of nonlinear beams.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using GEBT, LinearAlgebra\n\n# problem constants\nR = 100\nL = R*pi/4 # inches\nh = w = 1 # inches\nE = 1e7 # psi Young's Modulus\nν = 0.0\nG = E/(2*(1+ν))\n\n# beam starting point and curvature\nr = [0, 0, 0]\nframe = [0 -1 0; 1 0 0; 0 0 1]\nk = [0, 0, -1/R]\n\n# cross section properties\nA = h*w\nAy = A\nAz = A\nIyy = w*h^3/12\nIzz = w^3*h/12\nJ = Iyy + Izz\n\n# discretize the beam\nnelem = 16\nΔL, xp, xm, Cab = discretize_beam(L, r, nelem, Cab=frame, k = k)\n\n# force\nP = 600 # lbs\n\n# index of left and right endpoints of each beam element\npt1 = 1:nelem\npt2 = 2:nelem+1\n\n# compliance matrix for each beam element\ncompliance = fill(Diagonal([1/(E*A), 1/(G*Ay), 1/(G*Az), 1/(G*J), 1/(E*Iyy), 1/(E*Izz)]), nelem)\n\n# create assembly of interconnected nonlinear beams\nassembly = Assembly(xp, pt1, pt2, compliance=compliance, frames=Cab,\n    lengths=ΔL, midpoints=xm)\n\n# create dictionary of prescribed conditions\nprescribed_conditions = Dict(\n    # fixed left endpoint\n    1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0),\n    # force on right endpoint\n    nelem+1 => PrescribedConditions(Fz=P)\n)\n\nsystem, converged = static_analysis(assembly, prescribed_conditions=prescribed_conditions)\n\nstate = AssemblyState(system, assembly, prescribed_conditions=prescribed_conditions)\n\nprintln(\"Tip Displacement: \", state.points[end].u)\nprintln(\"Tip Displacement (Bathe and Bolourch): [-13.4, -23.5, 53.4]\")\n\n# write a file that can be visualized in ParaView\nwrite_vtk(\"cantilever-curved\", assembly, state)\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The calculated tip displacements match those reported by Bathe and Bolourch in \"Large Displacement Analysis of Three-Dimensional Beam Structures\" closely, thus verifying our GEBT implementation.","category":"page"},{"location":"examples/#Rotating-Beam-with-a-Swept-Tip","page":"Examples","title":"Rotating Beam with a Swept Tip","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this example we analyze a rotating beam with a swept tip.  The parameters for this example come from \"Finite element solution of nonlinear intrinsic equations for curved composite beams\" by Hodges, Shang, and Cesnik.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing GEBT, LinearAlgebra\n\nsweep = 45 * pi/180\nrpm = 0:25:750\n\n# straight section of the beam\nL_b1 = 31.5 # inch\nr_b1 = [2.5, 0, 0]\nnelem_b1 = 13\nlengths_b1, xp_b1, xm_b1, Cab_b1 = discretize_beam(L_b1, r_b1, nelem_b1)\n\n# swept section of the beam\nL_b2 = 6 # inch\nr_b2 = [34, 0, 0]\nnelem_b2 = 3\ncs, ss = cos(sweep), sin(sweep)\nframe_b2 = [cs ss 0; -ss cs 0; 0 0 1]\nlengths_b2, xp_b2, xm_b2, Cab_b2 = discretize_beam(L_b2, r_b2, nelem_b2, Cab=frame_b2)\n\n# combine elements and points into one array\nnelem = nelem_b1 + nelem_b2\npoints = vcat(xp_b1, xp_b2[2:end])\nstart = 1:nelem_b1 + nelem_b2\nstop = 2:nelem_b1 + nelem_b2 + 1\nlengths = vcat(lengths_b1, lengths_b2)\nmidpoints = vcat(xm_b1, xm_b2)\nCab = vcat(Cab_b1, Cab_b2)\n\n# cross section\nw = 1 # inch\nh = 0.063 # inch\n\n# material properties\nE = 1.06e7 # lb/in^2\nν = 0.325\nρ = 2.51e-4 # lb sec^2/in^4\n\n# shear and torsion correction factors\nky = 1.2000001839588001\nkz = 14.625127919304001\nkt = 65.85255016982444\n\nA = h*w\nIyy = w*h^3/12\nIzz = w^3*h/12\nJ = Iyy + Izz\n\n# apply corrections\nAy = A/ky\nAz = A/kz\nJx = J/kt\n\nG = E/(2*(1+ν))\n\ncompliance = fill(Diagonal([1/(E*A), 1/(G*Ay), 1/(G*Az), 1/(G*Jx), 1/(E*Iyy), 1/(E*Izz)]), nelem)\n\nmass = fill(Diagonal([ρ*A, ρ*A, ρ*A, ρ*J, ρ*Iyy, ρ*Izz]), nelem)\n\n# create assembly\nassembly = Assembly(points, start, stop, compliance=compliance, mass=mass, frames=Cab, lengths=lengths, midpoints=midpoints)\n\n# create dictionary of prescribed conditions\nprescribed_conditions = Dict(\n    # root section is fixed\n    1 => PrescribedConditions(ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0)\n    )\n\nnonlinear_states = Vector{AssemblyState{Float64}}(undef, length(rpm))\nlinear_states = Vector{AssemblyState{Float64}}(undef, length(rpm))\nfor i = 1:length(rpm)\n    # global frame rotation\n    w0 = [0, 0, rpm[i]*(2*pi)/60]\n\n    # perform nonlinear steady state analysis\n    system, converged = steady_state_analysis(assembly,\n        angular_velocity = w0,\n        prescribed_conditions = prescribed_conditions)\n\n    nonlinear_states[i] = AssemblyState(system, assembly, prescribed_conditions=prescribed_conditions)\n\n    # perform linear steady state analysis\n    system, converged = steady_state_analysis(assembly,\n        angular_velocity = w0,\n        prescribed_conditions = prescribed_conditions,\n        linear = true)\n\n    linear_states[i] = AssemblyState(system, assembly, prescribed_conditions=prescribed_conditions)\nend\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"To visualize the solutions we will plot the root moment and tip deflections against the angular speed.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using Plots\npyplot()\n\n# root moment\nplot(\n    xlim = (0, 760),\n    xticks = 0:100:750,\n    xlabel = \"Angular Speed (RPM)\",\n    yticks = 0.0:2:12,\n    ylabel = \"\\$M_z\\$ at the root (lb-in)\",\n    grid = false,\n    overwrite_figure=false\n    )\nMz_nl = [-nonlinear_states[i].points[1].M[3] for i = 1:length(rpm)]\nMz_l = [-linear_states[i].points[1].M[3] for i = 1:length(rpm)]\nplot!(rpm, Mz_nl, label=\"Nonlinear\")\nplot!(rpm, Mz_l, label=\"Linear\")\n\n# x tip deflection\nplot(\n    xlim = (0, 760),\n    xticks = 0:100:750,\n    xlabel = \"Angular Speed (RPM)\",\n    ylim = (-0.002, 0.074),\n    yticks = 0.0:0.01:0.07,\n    ylabel = \"\\$u_x\\$ at the tip (in)\",\n    grid = false,\n    overwrite_figure=false\n    )\nux_nl = [nonlinear_states[i].points[end].u[1] for i = 1:length(rpm)]\nux_l = [linear_states[i].points[end].u[1] for i = 1:length(rpm)]\nplot!(rpm, ux_nl, label=\"Nonlinear\")\nplot!(rpm, ux_l, label=\"Linear\")\n\nsavefig(\"rotating-beam-1.svg\"); nothing #hide\n\n# y tip deflection\nplot(\n    xlim = (0, 760),\n    xticks = 0:100:750,\n    xlabel = \"Angular Speed (RPM)\",\n    ylim = (-0.01, 0.27),\n    yticks = 0.0:0.05:0.25,\n    ylabel = \"\\$u_y\\$ at the tip (in)\",\n    grid = false,\n    overwrite_figure=false\n    )\nuy_nl = [nonlinear_states[i].points[end].u[2] for i = 1:length(rpm)]\nuy_l = [linear_states[i].points[end].u[2] for i = 1:length(rpm)]\nplot!(rpm, uy_nl, label=\"Nonlinear\")\nplot!(rpm, uy_l, label=\"Linear\")\n\nsavefig(\"rotating-beam-2.svg\"); nothing #hide\n\n# rotation of the tip\nplot(\n    xlim = (0, 760),\n    xticks = 0:100:750,\n    xlabel = \"Angular Speed (RPM)\",\n    ylabel = \"\\$θ_z\\$ at the tip\",\n    grid = false,\n    overwrite_figure=false\n    )\ntheta_z_nl = [4*atan(nonlinear_states[i].points[end].theta[3]/4) for i = 1:length(rpm)]\ntheta_z_l = [4*atan(linear_states[i].points[end].theta[3]/4) for i = 1:length(rpm)]\n\nplot!(rpm, theta_z_nl, label=\"Nonlinear\")\nplot!(rpm, theta_z_l, label=\"Linear\")\n\nsavefig(\"rotating-beam-3.svg\"); nothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We will now compute the eigenvalues of this system for a range of sweep angles and and angular speeds.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nsweep = (0:5:45) * pi/180\nrpm = [0, 500, 750]\nnev = 30\n\nλ = Matrix{Vector{ComplexF64}}(undef, length(sweep), length(rpm))\nU = Matrix{Matrix{ComplexF64}}(undef, length(sweep), length(rpm))\nMV = Matrix{Matrix{ComplexF64}}(undef, length(sweep), length(rpm))\nstate = Matrix{AssemblyState{Float64}}(undef, length(sweep), length(rpm))\neigenstates = Matrix{Vector{AssemblyState{ComplexF64}}}(undef, length(sweep), length(rpm))\nfor i = 1:length(sweep)\n    # straight section of the beam\n    L_b1 = 31.5 # inch\n    r_b1 = [2.5, 0, 0]\n    nelem_b1 = 20\n    lengths_b1, xp_b1, xm_b1, Cab_b1 = discretize_beam(L_b1, r_b1, nelem_b1)\n\n    # swept section of the beam\n    L_b2 = 6 # inch\n    r_b2 = [34, 0, 0]\n    nelem_b2 = 20\n    cs, ss = cos(sweep[i]), sin(sweep[i])\n    frame_b2 = [cs ss 0; -ss cs 0; 0 0 1]\n    lengths_b2, xp_b2, xm_b2, Cab_b2 = discretize_beam(L_b2, r_b2, nelem_b2, Cab=frame_b2)\n\n    # combine elements and points into one array\n    nelem = nelem_b1 + nelem_b2\n    points = vcat(xp_b1, xp_b2[2:end])\n    start = 1:nelem_b1 + nelem_b2\n    stop = 2:nelem_b1 + nelem_b2 + 1\n    lengths = vcat(lengths_b1, lengths_b2)\n    midpoints = vcat(xm_b1, xm_b2)\n    Cab = vcat(Cab_b1, Cab_b2)\n\n    compliance = fill(Diagonal([1/(E*A), 1/(G*Ay), 1/(G*Az), 1/(G*Jx), 1/(E*Iyy), 1/(E*Izz)]), nelem)\n\n    mass = fill(Diagonal([ρ*A, ρ*A, ρ*A, ρ*J, ρ*Iyy, ρ*Izz]), nelem)\n\n    # create assembly\n    assembly = Assembly(points, start, stop, compliance=compliance, mass=mass, frames=Cab, lengths=lengths, midpoints=midpoints)\n\n    # create system\n    keep_points = [1, nelem_b1+1, nelem+1] # points that we request are included in the system of equations\n    system = System(assembly, keep_points, false)\n\n    for j = 1:length(rpm)\n        # global frame rotation\n        w0 = [0, 0, rpm[j]*(2*pi)/60]\n\n        # eigenvalues and (right) eigenvectors\n        system, λ[i,j], V, converged = eigenvalue_analysis!(system, assembly,\n            angular_velocity = w0,\n            prescribed_conditions = prescribed_conditions,\n            nev=nev)\n\n        # corresponding left eigenvectors\n        U[i,j] = left_eigenvectors(system, λ[i,j], V)\n\n        # post-multiply mass matrix with right eigenvector matrix\n        # (we use this later for correlating eigenvalues)\n        MV[i,j] = system.M * V\n\n        # process state and eigenstates\n        state[i,j] = AssemblyState(system, assembly; prescribed_conditions=prescribed_conditions)\n        eigenstates[i,j] = [AssemblyState(system, assembly, V[:,k];\n            prescribed_conditions=prescribed_conditions) for k = 1:nev]\n    end\nend\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can correlate each eigenmode by taking advantage of the fact that left and right eigenvectors satisfy the following relationships:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"beginaligned\nu^H M v = 1 textif (u) and (v) correspond to the same eigenmode \nu^H M v = 0 textif (u) and (v) correspond to different eigenmodes\nendaligned","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\n# set previous left eigenvector matrix\nU_p = copy(U[1,1])\n\nfor j = 1:length(rpm)\n    for i = 1:length(sweep)\n        # construct correlation matrix\n        C = U_p*MV[i,j]\n\n        # correlate eigenmodes\n        perm, corruption = correlate_eigenmodes(C)\n\n        # re-arrange eigenvalues and eigenvectors\n        λ[i,j] = λ[i,j][perm]\n        U[i,j] = U[i,j][perm,:]\n        MV[i,j] = MV[i,j][:,perm]\n        eigenstates[i,j] = eigenstates[i,j][perm]\n\n        # update previous eigenvector matrix\n        U_p .= U[i,j]\n    end\n    # update previous eigenvector matrix\n    U_p .= U[1,j]\nend\n\nfrequency = [[imag(λ[i,j][k])/(2*pi) for i = 1:length(sweep), j=1:length(rpm)] for k = 2:2:nev]\n\nnames = [\"First Bending Mode\", \"Second Bending Mode\", \"Third Bending Mode\"]\nindices = [1, 2, 5]\n\nfor k = 1:length(indices)\n    plot(\n        title = names[k],\n        xticks = 0:15:45,\n        xlabel = \"Sweep Angle (degrees)\",\n        ylim = (0, Inf),\n        ylabel = \"Frequency (Hz)\",\n        grid = false,\n        overwrite_figure=false\n        )\n\n    for j = length(rpm):-1:1\n        plot!(sweep*180/pi, frequency[indices[k]][:,j], label=\"$(rpm[j]) RPM\")\n    end\n\n    plot!(show=true)\n    savefig(\"rotating-beam-frequencies-$(k).svg\") #hide\nend\n\nnames = [\"1T/5B\", \"5B/1T\", \"4B/1T\"]\nindices = [6, 7, 5]\n\nplot(\n    title = \"Coupled Torsion-Bending Modes at 750 RPM\",\n    xticks = 0:15:45,\n    xlabel = \"Sweep Angle (degrees)\",\n    ylim = (0, Inf),\n    ylabel = \"Frequency (Hz)\",\n    grid = false,\n    overwrite_figure=false\n    )\n\nfor k = 1:length(indices)\n    plot!(sweep*180/pi, frequency[indices[k]][:,end], label=names[k])\nend\n\nplot!(show=true)\n\nsavefig(\"rotating-beam-frequencies-4.svg\"); nothing #hide\n\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: ) (Image: ) (Image: ) (Image: )","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"In this case our eigenmode correlations worked, but remember that large changes in the underlying parameters (or just drastic changes in the eigenvectors themselves due to a small perturbation) can cause these automatic eigenmode correlations to fail.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can also visualize eigenmodes using ParaView.  Here we will visualize the first bending mode for the 45 degree swept tip at a rotational speed of 750 RPM.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"write_vtk(\"rotating-beam-45d-750rpm-bending-mode-1\", assembly, state[end,end], λ[end,end][1], eigenstates[end,end][1], mode_scaling=100.0)\nnothing #hide","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: )","category":"page"},{"location":"examples/#Nonlinear-Time-Marching-and-Eigenvalue-Analysis-of-a-Beam-Assembly","page":"Examples","title":"Nonlinear Time-Marching and Eigenvalue Analysis of a Beam Assembly","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing GEBT, LinearAlgebra\n\nnelem = 20\nnelem_b1 = div(nelem, 2)\nnelem_b2 = div(nelem, 2)\n\n# beam 1\nL_b1 = sqrt(1 + 0.5^2)\nr_b1 = [0, -0.5, 0]\ns_b1, c_b1 = 0.5/L_b1, 1/L_b1\nframe_b1 = [c_b1 -s_b1 0; s_b1 c_b1 0; 0 0 1]\nlengths_b1, xp_b1, xm_b1, Cab_b1 = discretize_beam(L_b1, r_b1, nelem_b1, Cab=frame_b1)\n\n# beam 2\nL_b2 = sqrt(1 + 0.5^2)\nr_b2 = [1, 0.0, 0]\ns_b2, c_b2 = 0.5/L_b2, -1/L_b2\nframe_b2 = [c_b2 -s_b2 0; s_b2 c_b2 0; 0 0 1]\nlengths_b2, xp_b2, xm_b2, Cab_b2 = discretize_beam(L_b2, r_b2, nelem_b2, Cab=frame_b2)\n\n# combine elements and points into one array\npoints = vcat(xp_b1, xp_b2[2:end])\nstart = 1:nelem_b1 + nelem_b2\nstop = 2:nelem_b1 + nelem_b2 + 1\nlengths = vcat(lengths_b1, lengths_b2)\nmidpoints = vcat(xm_b1, xm_b2)\nCab = vcat(Cab_b1, Cab_b2)\n\n# cross-sections for both beams\nw = 0.1 # meters\nh = 0.05 # meters\n\nE = 70e9 # Pa\nν = 0.35\nρ = 2700 # kg/m^3\n\n# shear correction factors\nAR = w/h\nky = 6/5 + (ν/(1+ν))^2*AR^-4*(1/5 - 18/(AR*pi^5)*sum([tanh(m*pi*AR)/m^5 for m = 1:1000]))\nkz = 6/5 + (ν/(1+ν))^2*AR^4*(1/5 - 18/(pi^5)*sum([tanh(n*pi*AR^-1)/n^5 for n = 1:1000]))\n\nA = h*w\nAy = A/ky\nAz = A/kz\nIyy = w*h^3/12\nIzz = w^3*h/12\nJ = Iyy + Izz\n\nG = E/(2*(1+ν))\n\ncompliance = fill(Diagonal([1/(E*A), 1/(G*Ay), 1/(G*Az), 1/(G*J), 1/(E*Iyy), 1/(E*Izz)]), nelem)\n\nminv = fill(Diagonal([ρ*A, ρ*A, ρ*A, ρ*J, ρ*Iyy, ρ*Izz])^-1, nelem)\n\n# create assembly\nassembly = Assembly(points, start, stop, compliance=compliance, minv=minv,\n    frames=Cab, lengths=lengths, midpoints=midpoints)\n\n# time\ndt = 0.001\nt = 0:dt:0.5\nnstep = length(t)\n\n# create dictionary of prescribed conditions\nprescribed_conditions = Dict(\n    # fixed endpoint on beam 1\n    1 => PrescribedConditions(dt, nstep=nstep, ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0),\n    # fixed endpoint on beam 2\n    nelem+1 => PrescribedConditions(dt, nstep=nstep, ux=0, uy=0, uz=0, theta_x=0, theta_y=0, theta_z=0),\n    # force applied on connected endpoint\n    nelem_b1+1 => PrescribedConditions(dt, nstep=nstep, Fz=(t)->1e5*sin(20*t))\n)\n\nsystem, history, converged = time_domain_analysis(assembly, dt,\n    prescribed_conditions=prescribed_conditions, nstep = nstep)\n\nsystem, λ, V, converged = eigenvalue_analysis(assembly,\n    prescribed_conditions=prescribed_conditions, nstep = nstep, nev = 50)\n\nUs = left_eigenvectors(system, λ, V)\n\nnothing #hide","category":"page"},{"location":"#GEBT.jl","page":"Home","title":"GEBT.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: ) (Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Almost) Pure Julia Implementation of Geometrically Exact Beam Theory","category":"page"},{"location":"","page":"Home","title":"Home","text":"Author: Taylor McDonnell","category":"page"},{"location":"","page":"Home","title":"Home","text":"GEBT.jl is an (almost) pure Julia implementation of Geometrically Exact Beam Theory, based on the similarly named open source GEBT code by Wenbin Yu and its associated papers[1][2].  The \"almost\" here refers to the fact that the Fortran library ARPACK is used for eigenvalue computations.  Otherwise the code is written with pure Julia and should work with custom types and automatic differentiation packages such as ForwardDiff.","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Performs multiple types of analyses including:\nLinear/Nonlinear static analyses\nLinear/Nonlinear steady-state dynamic analyses\nLinear/Nonlinear eigenvalue analyses (by linearizing about a steady state condition)\nLinear/Nonlinear time-marching dynamic analyses\nAccurately models arbitrary systems of interconnected highly flexible composite beams.\nCaptures all geometric nonlinearities due to large deflections and rotations\nCapable of using the full 6x6 Timoshenko beam stiffness matrix\nModels arbitrary time-varying distributed forces/moments on beam elements using:\nDead forces/moments (which do not rotate as the beam element rotates)\nFollower forces/moments (which rotate as the beam element rotates)\nModels arbitrary time-varying prescribed forces/moments and/or displacements/rotations at the connection points between beam elements using:\nDead forces/moments (which do not rotate as the point rotates)\nFollower forces/moments (which rotate as the point rotates)\nCapable of using arbitrary units (as long as they are compatible)\nSimple result visualization using WriteVTK\nThoroughly validated against published analytical and computational results.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Enter the package manager by typing ] and then run the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/byuflowlab/GEBT.jl","category":"page"},{"location":"#Performance","page":"Home","title":"Performance","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This code has been optimized to be highly performant, primarily by maintaining type stability and minimizing allocations.  As a result the performance of this package rivals (and sometimes beats) that of the Fortran implementation of GEBT provided by Wenbin Yu.  At this point, differences in performance between the two codes can be primarily attributed to the performance of the sparse linear system solver in each.","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the examples","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that while the theory is identical to the Wenbin Yu's code, some of the implementation details vary.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1] Yu, W., & Blair, M. (2012). GEBT: A general-purpose nonlinear analysis tool for composite beams. Composite Structures, 94(9), 2677-2689.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[2] Wang, Q., & Yu, W. (2017). Geometrically nonlinear analysis of composite beams using Wiener-Milenković parameters. Journal of Renewable and Sustainable Energy, 9(3), 033306.","category":"page"}]
}
